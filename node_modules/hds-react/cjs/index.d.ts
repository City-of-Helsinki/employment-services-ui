/// <reference types="react" />
import React from "react";
import { SVGAttributes } from "react";
import { A11yRemovalMessage, A11yStatusMessageOptions, UseMultipleSelectionStateChange, UseMultipleSelectionStateChangeOptions, UseMultipleSelectionState } from "downshift";
import { Placement } from "@popperjs/core";
type IconProps = SVGAttributes<SVGElement> & {
    /**
     * Icon size
     */
    size?: "xs" | "s" | "m" | "l" | "xl";
};
declare const IconDiscord: ({ size, className, style, ...rest }: IconProps) => JSX.Element;
declare const IconFacebook: ({ size, className, style, ...rest }: IconProps) => JSX.Element;
declare const IconGoogle: ({ size, className, style, ...rest }: IconProps) => JSX.Element;
declare const IconInstagram: ({ size, className, style, ...rest }: IconProps) => JSX.Element;
declare const IconLinkedin: ({ size, className, style, ...rest }: IconProps) => JSX.Element;
declare const IconRss: ({ size, className, style, ...rest }: IconProps) => JSX.Element;
declare const IconSnapchat: ({ size, className, style, ...rest }: IconProps) => JSX.Element;
declare const IconTiktok: ({ size, className, style, ...rest }: IconProps) => JSX.Element;
declare const IconTwitch: ({ size, className, style, ...rest }: IconProps) => JSX.Element;
declare const IconTwitter: ({ size, className, style, ...rest }: IconProps) => JSX.Element;
declare const IconVimeo: ({ size, className, style, ...rest }: IconProps) => JSX.Element;
declare const IconYle: ({ size, className, style, ...rest }: IconProps) => JSX.Element;
declare const IconYoutube: ({ size, className, style, ...rest }: IconProps) => JSX.Element;
declare const IconAlertCircle: ({ size, className, style, ...rest }: IconProps) => JSX.Element;
declare const IconAngleRight: ({ size, className, style, ...rest }: IconProps) => JSX.Element;
declare const IconAngleLeft: ({ size, className, style, ...rest }: IconProps) => JSX.Element;
declare const IconAngleDown: ({ size, className, style, ...rest }: IconProps) => JSX.Element;
declare const IconAngleUp: ({ size, className, style, ...rest }: IconProps) => JSX.Element;
declare const IconArrowDown: ({ size, className, style, ...rest }: IconProps) => JSX.Element;
declare const IconArrowLeft: ({ size, className, style, ...rest }: IconProps) => JSX.Element;
declare const IconArrowRedo: ({ size, className, style, ...rest }: IconProps) => JSX.Element;
declare const IconArrowUndo: ({ size, className, style, ...rest }: IconProps) => JSX.Element;
declare const IconArrowRight: ({ size, className, style, ...rest }: IconProps) => JSX.Element;
declare const IconArrowUp: ({ size, className, style, ...rest }: IconProps) => JSX.Element;
declare const IconBellCrossed: ({ size, className, style, ...rest }: IconProps) => JSX.Element;
declare const IconCalendarClock: ({ size, className, style, ...rest }: IconProps) => JSX.Element;
declare const IconCalendarPlus: ({ size, className, style, ...rest }: IconProps) => JSX.Element;
declare const IconCalendarCross: ({ size, className, style, ...rest }: IconProps) => JSX.Element;
declare const IconBell: ({ size, className, style, ...rest }: IconProps) => JSX.Element;
declare const IconCalendar: ({ size, className, style, ...rest }: IconProps) => JSX.Element;
declare const IconCamera: ({ size, className, style, ...rest }: IconProps) => JSX.Element;
declare const IconCheck: ({ size, className, style, ...rest }: IconProps) => JSX.Element;
declare const IconClockCross: ({ size, className, style, ...rest }: IconProps) => JSX.Element;
declare const IconClockPlus: ({ size, className, style, ...rest }: IconProps) => JSX.Element;
declare const IconClock: ({ size, className, style, ...rest }: IconProps) => JSX.Element;
declare const IconCogwheel: ({ size, className, style, ...rest }: IconProps) => JSX.Element;
declare const IconCrossCircle: ({ size, className, style, ...rest }: IconProps) => JSX.Element;
declare const IconCross: ({ size, className, style, ...rest }: IconProps) => JSX.Element;
declare const IconDisplay: ({ size, className, style, ...rest }: IconProps) => JSX.Element;
declare const IconDownloadCloud: ({ size, className, style, ...rest }: IconProps) => JSX.Element;
declare const IconDownload: ({ size, className, style, ...rest }: IconProps) => JSX.Element;
declare const IconEnvelope: ({ size, className, style, ...rest }: IconProps) => JSX.Element;
declare const IconEye: ({ size, className, style, ...rest }: IconProps) => JSX.Element;
declare const IconFaceNeutral: ({ size, className, style, ...rest }: IconProps) => JSX.Element;
declare const IconEyeCrossed: ({ size, className, style, ...rest }: IconProps) => JSX.Element;
declare const IconError: ({ size, className, style, ...rest }: IconProps) => JSX.Element;
declare const IconFaceSad: ({ size, className, style, ...rest }: IconProps) => JSX.Element;
declare const IconGlobe: ({ size, className, style, ...rest }: IconProps) => JSX.Element;
declare const IconFaceSmile: ({ size, className, style, ...rest }: IconProps) => JSX.Element;
declare const IconGroup: ({ size, className, style, ...rest }: IconProps) => JSX.Element;
declare const IconHeartFill: ({ size, className, style, ...rest }: IconProps) => JSX.Element;
declare const IconHomeSmoke: ({ size, className, style, ...rest }: IconProps) => JSX.Element;
declare const IconHeart: ({ size, className, style, ...rest }: IconProps) => JSX.Element;
declare const IconInfoCircle: ({ size, className, style, ...rest }: IconProps) => JSX.Element;
declare const IconHome: ({ size, className, style, ...rest }: IconProps) => JSX.Element;
declare const IconLinkExternal: ({ size, className, style, ...rest }: IconProps) => JSX.Element;
declare const IconLink: ({ size, className, style, ...rest }: IconProps) => JSX.Element;
declare const IconLocate: ({ size, className, style, ...rest }: IconProps) => JSX.Element;
declare const IconLock: ({ size, className, style, ...rest }: IconProps) => JSX.Element;
declare const IconLocation: ({ size, className, style, ...rest }: IconProps) => JSX.Element;
declare const IconLockOpen: ({ size, className, style, ...rest }: IconProps) => JSX.Element;
declare const IconMap: ({ size, className, style, ...rest }: IconProps) => JSX.Element;
declare const IconMenuDots: ({ size, className, style, ...rest }: IconProps) => JSX.Element;
declare const IconMenuHamburger: ({ size, className, style, ...rest }: IconProps) => JSX.Element;
declare const IconMicrophone: ({ size, className, style, ...rest }: IconProps) => JSX.Element;
declare const IconMicrophoneCrossed: ({ size, className, style, ...rest }: IconProps) => JSX.Element;
declare const IconMinusCircle: ({ size, className, style, ...rest }: IconProps) => JSX.Element;
declare const IconMinus: ({ size, className, style, ...rest }: IconProps) => JSX.Element;
declare const IconPaperclip: ({ size, className, style, ...rest }: IconProps) => JSX.Element;
declare const IconMobile: ({ size, className, style, ...rest }: IconProps) => JSX.Element;
declare const IconPenLine: ({ size, className, style, ...rest }: IconProps) => JSX.Element;
declare const IconPen: ({ size, className, style, ...rest }: IconProps) => JSX.Element;
declare const IconPersonFemale: ({ size, className, style, ...rest }: IconProps) => JSX.Element;
declare const IconPersonMale: ({ size, className, style, ...rest }: IconProps) => JSX.Element;
declare const IconPersonWheelchair: ({ size, className, style, ...rest }: IconProps) => JSX.Element;
declare const IconPhone: ({ size, className, style, ...rest }: IconProps) => JSX.Element;
declare const IconPlusCircle: ({ size, className, style, ...rest }: IconProps) => JSX.Element;
declare const IconPhoto: ({ size, className, style, ...rest }: IconProps) => JSX.Element;
declare const IconPhotoPlus: ({ size, className, style, ...rest }: IconProps) => JSX.Element;
declare const IconPlus: ({ size, className, style, ...rest }: IconProps) => JSX.Element;
declare const IconQuestionCircle: ({ size, className, style, ...rest }: IconProps) => JSX.Element;
declare const IconShare: ({ size, className, style, ...rest }: IconProps) => JSX.Element;
declare const IconSearch: ({ size, className, style, ...rest }: IconProps) => JSX.Element;
declare const IconSignin: ({ size, className, style, ...rest }: IconProps) => JSX.Element;
declare const IconSignout: ({ size, className, style, ...rest }: IconProps) => JSX.Element;
declare const IconSpeechbubbleText: ({ size, className, style, ...rest }: IconProps) => JSX.Element;
declare const IconSpeechbubble: ({ size, className, style, ...rest }: IconProps) => JSX.Element;
declare const IconStarFill: ({ size, className, style, ...rest }: IconProps) => JSX.Element;
declare const IconStar: ({ size, className, style, ...rest }: IconProps) => JSX.Element;
declare const IconTicket: ({ size, className, style, ...rest }: IconProps) => JSX.Element;
declare const IconTrash: ({ size, className, style, ...rest }: IconProps) => JSX.Element;
declare const IconUploadCloud: ({ size, className, style, ...rest }: IconProps) => JSX.Element;
declare const IconUpload: ({ size, className, style, ...rest }: IconProps) => JSX.Element;
declare const IconUser: ({ size, className, style, ...rest }: IconProps) => JSX.Element;
declare const IconVideocameraCrossed: ({ size, className, style, ...rest }: IconProps) => JSX.Element;
declare const IconVideocamera: ({ size, className, style, ...rest }: IconProps) => JSX.Element;
declare const IconVolumeHigh: ({ size, className, style, ...rest }: IconProps) => JSX.Element;
declare const IconVolumeMinus: ({ size, className, style, ...rest }: IconProps) => JSX.Element;
declare const IconVolumeLow: ({ size, className, style, ...rest }: IconProps) => JSX.Element;
declare const IconVolumeMute: ({ size, className, style, ...rest }: IconProps) => JSX.Element;
declare const IconWifiCrossed: ({ size, className, style, ...rest }: IconProps) => JSX.Element;
declare const IconVolumePlus: ({ size, className, style, ...rest }: IconProps) => JSX.Element;
declare const IconWifi: ({ size, className, style, ...rest }: IconProps) => JSX.Element;
declare const IconZoomIn: ({ size, className, style, ...rest }: IconProps) => JSX.Element;
declare const IconZoomOut: ({ size, className, style, ...rest }: IconProps) => JSX.Element;
declare const IconZoomText: ({ size, className, style, ...rest }: IconProps) => JSX.Element;
declare const IconAlertCircleFill: ({ size, className, style, ...rest }: IconProps) => JSX.Element;
declare const IconCake: ({ size, className, style, ...rest }: IconProps) => JSX.Element;
declare const IconCalendarRecurring: ({ size, className, style, ...rest }: IconProps) => JSX.Element;
declare const IconCheckCircleFill: ({ size, className, style, ...rest }: IconProps) => JSX.Element;
declare const IconCheckCircle: ({ size, className, style, ...rest }: IconProps) => JSX.Element;
declare const IconCrossCircleFill: ({ size, className, style, ...rest }: IconProps) => JSX.Element;
declare const IconDrag: ({ size, className, style, ...rest }: IconProps) => JSX.Element;
declare const IconErrorFill: ({ size, className, style, ...rest }: IconProps) => JSX.Element;
declare const IconInfoCircleFill: ({ size, className, style, ...rest }: IconProps) => JSX.Element;
declare const IconGlyphEuro: ({ size, className, style, ...rest }: IconProps) => JSX.Element;
declare const IconLayers: ({ size, className, style, ...rest }: IconProps) => JSX.Element;
declare const IconGlyphAt: ({ size, className, style, ...rest }: IconProps) => JSX.Element;
declare const IconPlaybackFastforward: ({ size, className, style, ...rest }: IconProps) => JSX.Element;
declare const IconMinusCircleFill: ({ size, className, style, ...rest }: IconProps) => JSX.Element;
declare const IconPlaybackPause: ({ size, className, style, ...rest }: IconProps) => JSX.Element;
declare const IconPlaybackPlay: ({ size, className, style, ...rest }: IconProps) => JSX.Element;
declare const IconPlaybackNext: ({ size, className, style, ...rest }: IconProps) => JSX.Element;
declare const IconPlaybackPrevious: ({ size, className, style, ...rest }: IconProps) => JSX.Element;
declare const IconPlaybackRecord: ({ size, className, style, ...rest }: IconProps) => JSX.Element;
declare const IconPlaybackRewind: ({ size, className, style, ...rest }: IconProps) => JSX.Element;
declare const IconPlaybackStop: ({ size, className, style, ...rest }: IconProps) => JSX.Element;
declare const IconPlusCircleFill: ({ size, className, style, ...rest }: IconProps) => JSX.Element;
declare const IconPodcast: ({ size, className, style, ...rest }: IconProps) => JSX.Element;
declare const IconPrinter: ({ size, className, style, ...rest }: IconProps) => JSX.Element;
declare const IconQuestionCircleFill: ({ size, className, style, ...rest }: IconProps) => JSX.Element;
declare const IconRefresh: ({ size, className, style, ...rest }: IconProps) => JSX.Element;
declare const IconSortAscending: ({ size, className, style, ...rest }: IconProps) => JSX.Element;
declare const IconSortAlphabeticalAscending: ({ size, className, style, ...rest }: IconProps) => JSX.Element;
declare const IconSliders: ({ size, className, style, ...rest }: IconProps) => JSX.Element;
declare const IconSortDescending: ({ size, className, style, ...rest }: IconProps) => JSX.Element;
declare const IconSortAlphabeticalDescending: ({ size, className, style, ...rest }: IconProps) => JSX.Element;
declare const IconSort: ({ size, className, style, ...rest }: IconProps) => JSX.Element;
interface AccordionCustomTheme {
    "--background-color"?: string;
    "--border-color"?: string;
    "--padding-horizontal"?: string;
    "--padding-vertical"?: string;
    "--header-font-color"?: string;
    "--header-font-size"?: string;
    "--header-line-height"?: string;
    "--button-size"?: string;
    "--button-border-color-hover"?: string;
    "--content-font-size"?: string;
    "--content-line-height"?: string;
}
type CommonAccordionProps = React.PropsWithChildren<{
    /**
     * If `true` border will be drawn around the accordion card.
     */
    border?: false;
    /**
     * Use the card variant if `true`
     */
    card?: false;
    /**
     * Additional class names for accordion
     */
    className?: string;
    /**
     * Heading text.
     */
    heading?: string;
    /**
     * Heading level
     * @default 2
     */
    headingLevel?: number;
    /**
     * The id for the accordion element
     */
    id?: string;
    /**
     * Additional styles
     */
    style?: React.CSSProperties;
    /**
     * Custom theme styles
     */
    theme?: AccordionCustomTheme;
}>;
type CardAccordionProps = Omit<CommonAccordionProps, "card" | "border"> & {
    /**
     * If `true` border will be drawn around the accordion card.
     */
    border?: boolean;
    /**
     * Use the card variant if `true`
     */
    card: true;
};
type AccordionProps = CommonAccordionProps | CardAccordionProps;
declare const Accordion: ({ border, card, children, className, heading, headingLevel, id, style, theme }: AccordionProps) => JSX.Element;
type AccordionConfig = {
    initiallyOpen: boolean;
};
type AccordionButtonProps = {
    onClick: () => void;
    "aria-expanded": boolean;
};
type AccordionContentProps = {
    style?: React.CSSProperties;
};
type AccordionState = {
    isOpen: boolean;
    openAccordion: () => void;
    closeAccordion: () => void;
    toggleAccordion: () => void;
    buttonProps: AccordionButtonProps;
    contentProps: AccordionContentProps;
};
declare const useAccordion: ({ initiallyOpen }: AccordionConfig) => AccordionState;
type ButtonSize = "default" | "small";
type ButtonTheme = "default" | "coat" | "black";
type ButtonVariant = "primary" | "secondary" | "supplementary" | "success" | "danger";
type CommonButtonProps = React.ComponentPropsWithoutRef<"button"> & {
    /**
     * The content of the button
     */
    children: React.ReactNode;
    /**
     * Additional class names to apply to the button
     */
    className?: string;
    /**
     * Defines the button variant
     */
    variant?: Exclude<ButtonVariant, "supplementary">;
    /**
     * Defines the button theme
     */
    theme?: ButtonTheme;
    /**
     * If `true`, the button will be disabled
     */
    disabled?: boolean;
    /**
     * If `true`, the button will take up the full width of its container
     */
    fullWidth?: boolean;
    /**
     * Element placed on the left side of the button label
     */
    iconLeft?: React.ReactNode;
    /**
     * Element placed on the right side of the button label
     */
    iconRight?: React.ReactNode;
    /**
     * The size of the button
     */
    size?: ButtonSize;
};
// Supplementary variant requires iconLeft or iconRight
type SupplementaryButtonProps = Omit<CommonButtonProps, "variant"> & {
    variant: "supplementary";
} & ({
    iconLeft: React.ReactNode;
} | {
    iconRight: React.ReactNode;
});
type ButtonProps = CommonButtonProps | SupplementaryButtonProps;
declare const Button: React.ForwardRefExoticComponent<(Pick<React.DetailedHTMLProps<React.ButtonHTMLAttributes<HTMLButtonElement>, HTMLButtonElement>, "className" | "style" | "color" | "id" | "lang" | "name" | "type" | "role" | "tabIndex" | "aria-activedescendant" | "aria-atomic" | "aria-autocomplete" | "aria-busy" | "aria-checked" | "aria-colcount" | "aria-colindex" | "aria-colspan" | "aria-controls" | "aria-current" | "aria-describedby" | "aria-details" | "aria-disabled" | "aria-dropeffect" | "aria-errormessage" | "aria-expanded" | "aria-flowto" | "aria-grabbed" | "aria-haspopup" | "aria-hidden" | "aria-invalid" | "aria-keyshortcuts" | "aria-label" | "aria-labelledby" | "aria-level" | "aria-live" | "aria-modal" | "aria-multiline" | "aria-multiselectable" | "aria-orientation" | "aria-owns" | "aria-placeholder" | "aria-posinset" | "aria-pressed" | "aria-readonly" | "aria-relevant" | "aria-required" | "aria-roledescription" | "aria-rowcount" | "aria-rowindex" | "aria-rowspan" | "aria-selected" | "aria-setsize" | "aria-sort" | "aria-valuemax" | "aria-valuemin" | "aria-valuenow" | "aria-valuetext" | "children" | "dangerouslySetInnerHTML" | "onCopy" | "onCopyCapture" | "onCut" | "onCutCapture" | "onPaste" | "onPasteCapture" | "onCompositionEnd" | "onCompositionEndCapture" | "onCompositionStart" | "onCompositionStartCapture" | "onCompositionUpdate" | "onCompositionUpdateCapture" | "onFocus" | "onFocusCapture" | "onBlur" | "onBlurCapture" | "onChange" | "onChangeCapture" | "onBeforeInput" | "onBeforeInputCapture" | "onInput" | "onInputCapture" | "onReset" | "onResetCapture" | "onSubmit" | "onSubmitCapture" | "onInvalid" | "onInvalidCapture" | "onLoad" | "onLoadCapture" | "onError" | "onErrorCapture" | "onKeyDown" | "onKeyDownCapture" | "onKeyPress" | "onKeyPressCapture" | "onKeyUp" | "onKeyUpCapture" | "onAbort" | "onAbortCapture" | "onCanPlay" | "onCanPlayCapture" | "onCanPlayThrough" | "onCanPlayThroughCapture" | "onDurationChange" | "onDurationChangeCapture" | "onEmptied" | "onEmptiedCapture" | "onEncrypted" | "onEncryptedCapture" | "onEnded" | "onEndedCapture" | "onLoadedData" | "onLoadedDataCapture" | "onLoadedMetadata" | "onLoadedMetadataCapture" | "onLoadStart" | "onLoadStartCapture" | "onPause" | "onPauseCapture" | "onPlay" | "onPlayCapture" | "onPlaying" | "onPlayingCapture" | "onProgress" | "onProgressCapture" | "onRateChange" | "onRateChangeCapture" | "onSeeked" | "onSeekedCapture" | "onSeeking" | "onSeekingCapture" | "onStalled" | "onStalledCapture" | "onSuspend" | "onSuspendCapture" | "onTimeUpdate" | "onTimeUpdateCapture" | "onVolumeChange" | "onVolumeChangeCapture" | "onWaiting" | "onWaitingCapture" | "onAuxClick" | "onAuxClickCapture" | "onClick" | "onClickCapture" | "onContextMenu" | "onContextMenuCapture" | "onDoubleClick" | "onDoubleClickCapture" | "onDrag" | "onDragCapture" | "onDragEnd" | "onDragEndCapture" | "onDragEnter" | "onDragEnterCapture" | "onDragExit" | "onDragExitCapture" | "onDragLeave" | "onDragLeaveCapture" | "onDragOver" | "onDragOverCapture" | "onDragStart" | "onDragStartCapture" | "onDrop" | "onDropCapture" | "onMouseDown" | "onMouseDownCapture" | "onMouseEnter" | "onMouseLeave" | "onMouseMove" | "onMouseMoveCapture" | "onMouseOut" | "onMouseOutCapture" | "onMouseOver" | "onMouseOverCapture" | "onMouseUp" | "onMouseUpCapture" | "onSelect" | "onSelectCapture" | "onTouchCancel" | "onTouchCancelCapture" | "onTouchEnd" | "onTouchEndCapture" | "onTouchMove" | "onTouchMoveCapture" | "onTouchStart" | "onTouchStartCapture" | "onPointerDown" | "onPointerDownCapture" | "onPointerMove" | "onPointerMoveCapture" | "onPointerUp" | "onPointerUpCapture" | "onPointerCancel" | "onPointerCancelCapture" | "onPointerEnter" | "onPointerEnterCapture" | "onPointerLeave" | "onPointerLeaveCapture" | "onPointerOver" | "onPointerOverCapture" | "onPointerOut" | "onPointerOutCapture" | "onGotPointerCapture" | "onGotPointerCaptureCapture" | "onLostPointerCapture" | "onLostPointerCaptureCapture" | "onScroll" | "onScrollCapture" | "onWheel" | "onWheelCapture" | "onAnimationStart" | "onAnimationStartCapture" | "onAnimationEnd" | "onAnimationEndCapture" | "onAnimationIteration" | "onAnimationIterationCapture" | "onTransitionEnd" | "onTransitionEndCapture" | "form" | "slot" | "title" | "dir" | "property" | "value" | "key" | "autoFocus" | "disabled" | "formAction" | "formEncType" | "formMethod" | "formNoValidate" | "formTarget" | "defaultChecked" | "defaultValue" | "suppressContentEditableWarning" | "suppressHydrationWarning" | "accessKey" | "contentEditable" | "contextMenu" | "draggable" | "hidden" | "placeholder" | "spellCheck" | "translate" | "radioGroup" | "about" | "datatype" | "inlist" | "prefix" | "resource" | "typeof" | "vocab" | "autoCapitalize" | "autoCorrect" | "autoSave" | "itemProp" | "itemScope" | "itemType" | "itemID" | "itemRef" | "results" | "security" | "unselectable" | "inputMode" | "is"> & {
    children: React.ReactNode;
    className?: string;
    variant?: Exclude<ButtonVariant, "supplementary">;
    theme?: ButtonTheme;
    disabled?: boolean;
    fullWidth?: boolean;
    iconLeft?: React.ReactNode;
    iconRight?: React.ReactNode;
    size?: ButtonSize;
} & React.RefAttributes<HTMLButtonElement>) | (Pick<CommonButtonProps, "size" | "className" | "style" | "color" | "id" | "lang" | "name" | "type" | "role" | "tabIndex" | "aria-activedescendant" | "aria-atomic" | "aria-autocomplete" | "aria-busy" | "aria-checked" | "aria-colcount" | "aria-colindex" | "aria-colspan" | "aria-controls" | "aria-current" | "aria-describedby" | "aria-details" | "aria-disabled" | "aria-dropeffect" | "aria-errormessage" | "aria-expanded" | "aria-flowto" | "aria-grabbed" | "aria-haspopup" | "aria-hidden" | "aria-invalid" | "aria-keyshortcuts" | "aria-label" | "aria-labelledby" | "aria-level" | "aria-live" | "aria-modal" | "aria-multiline" | "aria-multiselectable" | "aria-orientation" | "aria-owns" | "aria-placeholder" | "aria-posinset" | "aria-pressed" | "aria-readonly" | "aria-relevant" | "aria-required" | "aria-roledescription" | "aria-rowcount" | "aria-rowindex" | "aria-rowspan" | "aria-selected" | "aria-setsize" | "aria-sort" | "aria-valuemax" | "aria-valuemin" | "aria-valuenow" | "aria-valuetext" | "children" | "dangerouslySetInnerHTML" | "onCopy" | "onCopyCapture" | "onCut" | "onCutCapture" | "onPaste" | "onPasteCapture" | "onCompositionEnd" | "onCompositionEndCapture" | "onCompositionStart" | "onCompositionStartCapture" | "onCompositionUpdate" | "onCompositionUpdateCapture" | "onFocus" | "onFocusCapture" | "onBlur" | "onBlurCapture" | "onChange" | "onChangeCapture" | "onBeforeInput" | "onBeforeInputCapture" | "onInput" | "onInputCapture" | "onReset" | "onResetCapture" | "onSubmit" | "onSubmitCapture" | "onInvalid" | "onInvalidCapture" | "onLoad" | "onLoadCapture" | "onError" | "onErrorCapture" | "onKeyDown" | "onKeyDownCapture" | "onKeyPress" | "onKeyPressCapture" | "onKeyUp" | "onKeyUpCapture" | "onAbort" | "onAbortCapture" | "onCanPlay" | "onCanPlayCapture" | "onCanPlayThrough" | "onCanPlayThroughCapture" | "onDurationChange" | "onDurationChangeCapture" | "onEmptied" | "onEmptiedCapture" | "onEncrypted" | "onEncryptedCapture" | "onEnded" | "onEndedCapture" | "onLoadedData" | "onLoadedDataCapture" | "onLoadedMetadata" | "onLoadedMetadataCapture" | "onLoadStart" | "onLoadStartCapture" | "onPause" | "onPauseCapture" | "onPlay" | "onPlayCapture" | "onPlaying" | "onPlayingCapture" | "onProgress" | "onProgressCapture" | "onRateChange" | "onRateChangeCapture" | "onSeeked" | "onSeekedCapture" | "onSeeking" | "onSeekingCapture" | "onStalled" | "onStalledCapture" | "onSuspend" | "onSuspendCapture" | "onTimeUpdate" | "onTimeUpdateCapture" | "onVolumeChange" | "onVolumeChangeCapture" | "onWaiting" | "onWaitingCapture" | "onAuxClick" | "onAuxClickCapture" | "onClick" | "onClickCapture" | "onContextMenu" | "onContextMenuCapture" | "onDoubleClick" | "onDoubleClickCapture" | "onDrag" | "onDragCapture" | "onDragEnd" | "onDragEndCapture" | "onDragEnter" | "onDragEnterCapture" | "onDragExit" | "onDragExitCapture" | "onDragLeave" | "onDragLeaveCapture" | "onDragOver" | "onDragOverCapture" | "onDragStart" | "onDragStartCapture" | "onDrop" | "onDropCapture" | "onMouseDown" | "onMouseDownCapture" | "onMouseEnter" | "onMouseLeave" | "onMouseMove" | "onMouseMoveCapture" | "onMouseOut" | "onMouseOutCapture" | "onMouseOver" | "onMouseOverCapture" | "onMouseUp" | "onMouseUpCapture" | "onSelect" | "onSelectCapture" | "onTouchCancel" | "onTouchCancelCapture" | "onTouchEnd" | "onTouchEndCapture" | "onTouchMove" | "onTouchMoveCapture" | "onTouchStart" | "onTouchStartCapture" | "onPointerDown" | "onPointerDownCapture" | "onPointerMove" | "onPointerMoveCapture" | "onPointerUp" | "onPointerUpCapture" | "onPointerCancel" | "onPointerCancelCapture" | "onPointerEnter" | "onPointerEnterCapture" | "onPointerLeave" | "onPointerLeaveCapture" | "onPointerOver" | "onPointerOverCapture" | "onPointerOut" | "onPointerOutCapture" | "onGotPointerCapture" | "onGotPointerCaptureCapture" | "onLostPointerCapture" | "onLostPointerCaptureCapture" | "onScroll" | "onScrollCapture" | "onWheel" | "onWheelCapture" | "onAnimationStart" | "onAnimationStartCapture" | "onAnimationEnd" | "onAnimationEndCapture" | "onAnimationIteration" | "onAnimationIterationCapture" | "onTransitionEnd" | "onTransitionEndCapture" | "form" | "slot" | "title" | "dir" | "property" | "value" | "theme" | "key" | "autoFocus" | "disabled" | "formAction" | "formEncType" | "formMethod" | "formNoValidate" | "formTarget" | "defaultChecked" | "defaultValue" | "suppressContentEditableWarning" | "suppressHydrationWarning" | "accessKey" | "contentEditable" | "contextMenu" | "draggable" | "hidden" | "placeholder" | "spellCheck" | "translate" | "radioGroup" | "about" | "datatype" | "inlist" | "prefix" | "resource" | "typeof" | "vocab" | "autoCapitalize" | "autoCorrect" | "autoSave" | "itemProp" | "itemScope" | "itemType" | "itemID" | "itemRef" | "results" | "security" | "unselectable" | "inputMode" | "is" | "fullWidth" | "iconLeft" | "iconRight"> & {
    variant: "supplementary";
} & {
    iconLeft: React.ReactNode;
} & React.RefAttributes<HTMLButtonElement>) | (Pick<CommonButtonProps, "size" | "className" | "style" | "color" | "id" | "lang" | "name" | "type" | "role" | "tabIndex" | "aria-activedescendant" | "aria-atomic" | "aria-autocomplete" | "aria-busy" | "aria-checked" | "aria-colcount" | "aria-colindex" | "aria-colspan" | "aria-controls" | "aria-current" | "aria-describedby" | "aria-details" | "aria-disabled" | "aria-dropeffect" | "aria-errormessage" | "aria-expanded" | "aria-flowto" | "aria-grabbed" | "aria-haspopup" | "aria-hidden" | "aria-invalid" | "aria-keyshortcuts" | "aria-label" | "aria-labelledby" | "aria-level" | "aria-live" | "aria-modal" | "aria-multiline" | "aria-multiselectable" | "aria-orientation" | "aria-owns" | "aria-placeholder" | "aria-posinset" | "aria-pressed" | "aria-readonly" | "aria-relevant" | "aria-required" | "aria-roledescription" | "aria-rowcount" | "aria-rowindex" | "aria-rowspan" | "aria-selected" | "aria-setsize" | "aria-sort" | "aria-valuemax" | "aria-valuemin" | "aria-valuenow" | "aria-valuetext" | "children" | "dangerouslySetInnerHTML" | "onCopy" | "onCopyCapture" | "onCut" | "onCutCapture" | "onPaste" | "onPasteCapture" | "onCompositionEnd" | "onCompositionEndCapture" | "onCompositionStart" | "onCompositionStartCapture" | "onCompositionUpdate" | "onCompositionUpdateCapture" | "onFocus" | "onFocusCapture" | "onBlur" | "onBlurCapture" | "onChange" | "onChangeCapture" | "onBeforeInput" | "onBeforeInputCapture" | "onInput" | "onInputCapture" | "onReset" | "onResetCapture" | "onSubmit" | "onSubmitCapture" | "onInvalid" | "onInvalidCapture" | "onLoad" | "onLoadCapture" | "onError" | "onErrorCapture" | "onKeyDown" | "onKeyDownCapture" | "onKeyPress" | "onKeyPressCapture" | "onKeyUp" | "onKeyUpCapture" | "onAbort" | "onAbortCapture" | "onCanPlay" | "onCanPlayCapture" | "onCanPlayThrough" | "onCanPlayThroughCapture" | "onDurationChange" | "onDurationChangeCapture" | "onEmptied" | "onEmptiedCapture" | "onEncrypted" | "onEncryptedCapture" | "onEnded" | "onEndedCapture" | "onLoadedData" | "onLoadedDataCapture" | "onLoadedMetadata" | "onLoadedMetadataCapture" | "onLoadStart" | "onLoadStartCapture" | "onPause" | "onPauseCapture" | "onPlay" | "onPlayCapture" | "onPlaying" | "onPlayingCapture" | "onProgress" | "onProgressCapture" | "onRateChange" | "onRateChangeCapture" | "onSeeked" | "onSeekedCapture" | "onSeeking" | "onSeekingCapture" | "onStalled" | "onStalledCapture" | "onSuspend" | "onSuspendCapture" | "onTimeUpdate" | "onTimeUpdateCapture" | "onVolumeChange" | "onVolumeChangeCapture" | "onWaiting" | "onWaitingCapture" | "onAuxClick" | "onAuxClickCapture" | "onClick" | "onClickCapture" | "onContextMenu" | "onContextMenuCapture" | "onDoubleClick" | "onDoubleClickCapture" | "onDrag" | "onDragCapture" | "onDragEnd" | "onDragEndCapture" | "onDragEnter" | "onDragEnterCapture" | "onDragExit" | "onDragExitCapture" | "onDragLeave" | "onDragLeaveCapture" | "onDragOver" | "onDragOverCapture" | "onDragStart" | "onDragStartCapture" | "onDrop" | "onDropCapture" | "onMouseDown" | "onMouseDownCapture" | "onMouseEnter" | "onMouseLeave" | "onMouseMove" | "onMouseMoveCapture" | "onMouseOut" | "onMouseOutCapture" | "onMouseOver" | "onMouseOverCapture" | "onMouseUp" | "onMouseUpCapture" | "onSelect" | "onSelectCapture" | "onTouchCancel" | "onTouchCancelCapture" | "onTouchEnd" | "onTouchEndCapture" | "onTouchMove" | "onTouchMoveCapture" | "onTouchStart" | "onTouchStartCapture" | "onPointerDown" | "onPointerDownCapture" | "onPointerMove" | "onPointerMoveCapture" | "onPointerUp" | "onPointerUpCapture" | "onPointerCancel" | "onPointerCancelCapture" | "onPointerEnter" | "onPointerEnterCapture" | "onPointerLeave" | "onPointerLeaveCapture" | "onPointerOver" | "onPointerOverCapture" | "onPointerOut" | "onPointerOutCapture" | "onGotPointerCapture" | "onGotPointerCaptureCapture" | "onLostPointerCapture" | "onLostPointerCaptureCapture" | "onScroll" | "onScrollCapture" | "onWheel" | "onWheelCapture" | "onAnimationStart" | "onAnimationStartCapture" | "onAnimationEnd" | "onAnimationEndCapture" | "onAnimationIteration" | "onAnimationIterationCapture" | "onTransitionEnd" | "onTransitionEndCapture" | "form" | "slot" | "title" | "dir" | "property" | "value" | "theme" | "key" | "autoFocus" | "disabled" | "formAction" | "formEncType" | "formMethod" | "formNoValidate" | "formTarget" | "defaultChecked" | "defaultValue" | "suppressContentEditableWarning" | "suppressHydrationWarning" | "accessKey" | "contentEditable" | "contextMenu" | "draggable" | "hidden" | "placeholder" | "spellCheck" | "translate" | "radioGroup" | "about" | "datatype" | "inlist" | "prefix" | "resource" | "typeof" | "vocab" | "autoCapitalize" | "autoCorrect" | "autoSave" | "itemProp" | "itemScope" | "itemType" | "itemID" | "itemRef" | "results" | "security" | "unselectable" | "inputMode" | "is" | "fullWidth" | "iconLeft" | "iconRight"> & {
    variant: "supplementary";
} & {
    iconRight: React.ReactNode;
} & React.RefAttributes<HTMLButtonElement>)>;
interface CardCustomTheme {
    "--background-color"?: string;
    "--border-color"?: string;
    "--border-width"?: string;
    "--color"?: string;
    "--padding-horizontal": string;
    "--padding-vertical": string;
}
type CardProps = {
    /**
     * If `true` border will be drawn around the card.
     */
    border?: boolean;
    /**
     * Heading text.
     */
    heading?: string;
    /**
     * Body text.
     */
    text?: string;
    /**
     * Additional class names to apply to the card.
     */
    className?: string;
    /**
     * Custom theme styles
     */
    theme?: CardCustomTheme;
    /**
     * Additional children to render inside the card.
     */
    children?: React.ReactNode;
} & React.HTMLProps<HTMLDivElement>;
declare const Card: ({ border, heading, text, className, theme, children, ...divProps }: CardProps) => JSX.Element;
type CheckboxProps = React.ComponentPropsWithoutRef<"input"> & {
    /**
     * If `true`, the component is checked
     */
    checked?: boolean;
    /**
     * Additional class names to apply to the checkbox
     */
    className?: string;
    /**
     * If `true`, the checkbox will be disabled
     */
    disabled?: boolean;
    /**
     * The error text content that will be shown below the checkbox
     */
    errorText?: string;
    /**
     * The id of the input element
     */
    id: string;
    /**
     * The label for the checkbox
     */
    label?: string | React.ReactNode;
    /**
     * **[DEPRECATED]** This prop will be removed in a future version. Use the `label` prop instead
     * @deprecated
     */
    labelText?: string;
    /**
     * Callback fired when the state is changed
     */
    onChange?: React.ChangeEventHandler<HTMLInputElement>;
    /**
     * Override or extend the styles applied to the component
     */
    style?: React.CSSProperties;
    /**
     * The value of the component
     */
    value?: string;
};
declare const Checkbox: React.ForwardRefExoticComponent<Pick<React.DetailedHTMLProps<React.InputHTMLAttributes<HTMLInputElement>, HTMLInputElement>, "size" | "className" | "style" | "color" | "height" | "id" | "lang" | "max" | "min" | "name" | "type" | "width" | "role" | "tabIndex" | "crossOrigin" | "aria-activedescendant" | "aria-atomic" | "aria-autocomplete" | "aria-busy" | "aria-checked" | "aria-colcount" | "aria-colindex" | "aria-colspan" | "aria-controls" | "aria-current" | "aria-describedby" | "aria-details" | "aria-disabled" | "aria-dropeffect" | "aria-errormessage" | "aria-expanded" | "aria-flowto" | "aria-grabbed" | "aria-haspopup" | "aria-hidden" | "aria-invalid" | "aria-keyshortcuts" | "aria-label" | "aria-labelledby" | "aria-level" | "aria-live" | "aria-modal" | "aria-multiline" | "aria-multiselectable" | "aria-orientation" | "aria-owns" | "aria-placeholder" | "aria-posinset" | "aria-pressed" | "aria-readonly" | "aria-relevant" | "aria-required" | "aria-roledescription" | "aria-rowcount" | "aria-rowindex" | "aria-rowspan" | "aria-selected" | "aria-setsize" | "aria-sort" | "aria-valuemax" | "aria-valuemin" | "aria-valuenow" | "aria-valuetext" | "children" | "dangerouslySetInnerHTML" | "onCopy" | "onCopyCapture" | "onCut" | "onCutCapture" | "onPaste" | "onPasteCapture" | "onCompositionEnd" | "onCompositionEndCapture" | "onCompositionStart" | "onCompositionStartCapture" | "onCompositionUpdate" | "onCompositionUpdateCapture" | "onFocus" | "onFocusCapture" | "onBlur" | "onBlurCapture" | "onChange" | "onChangeCapture" | "onBeforeInput" | "onBeforeInputCapture" | "onInput" | "onInputCapture" | "onReset" | "onResetCapture" | "onSubmit" | "onSubmitCapture" | "onInvalid" | "onInvalidCapture" | "onLoad" | "onLoadCapture" | "onError" | "onErrorCapture" | "onKeyDown" | "onKeyDownCapture" | "onKeyPress" | "onKeyPressCapture" | "onKeyUp" | "onKeyUpCapture" | "onAbort" | "onAbortCapture" | "onCanPlay" | "onCanPlayCapture" | "onCanPlayThrough" | "onCanPlayThroughCapture" | "onDurationChange" | "onDurationChangeCapture" | "onEmptied" | "onEmptiedCapture" | "onEncrypted" | "onEncryptedCapture" | "onEnded" | "onEndedCapture" | "onLoadedData" | "onLoadedDataCapture" | "onLoadedMetadata" | "onLoadedMetadataCapture" | "onLoadStart" | "onLoadStartCapture" | "onPause" | "onPauseCapture" | "onPlay" | "onPlayCapture" | "onPlaying" | "onPlayingCapture" | "onProgress" | "onProgressCapture" | "onRateChange" | "onRateChangeCapture" | "onSeeked" | "onSeekedCapture" | "onSeeking" | "onSeekingCapture" | "onStalled" | "onStalledCapture" | "onSuspend" | "onSuspendCapture" | "onTimeUpdate" | "onTimeUpdateCapture" | "onVolumeChange" | "onVolumeChangeCapture" | "onWaiting" | "onWaitingCapture" | "onAuxClick" | "onAuxClickCapture" | "onClick" | "onClickCapture" | "onContextMenu" | "onContextMenuCapture" | "onDoubleClick" | "onDoubleClickCapture" | "onDrag" | "onDragCapture" | "onDragEnd" | "onDragEndCapture" | "onDragEnter" | "onDragEnterCapture" | "onDragExit" | "onDragExitCapture" | "onDragLeave" | "onDragLeaveCapture" | "onDragOver" | "onDragOverCapture" | "onDragStart" | "onDragStartCapture" | "onDrop" | "onDropCapture" | "onMouseDown" | "onMouseDownCapture" | "onMouseEnter" | "onMouseLeave" | "onMouseMove" | "onMouseMoveCapture" | "onMouseOut" | "onMouseOutCapture" | "onMouseOver" | "onMouseOverCapture" | "onMouseUp" | "onMouseUpCapture" | "onSelect" | "onSelectCapture" | "onTouchCancel" | "onTouchCancelCapture" | "onTouchEnd" | "onTouchEndCapture" | "onTouchMove" | "onTouchMoveCapture" | "onTouchStart" | "onTouchStartCapture" | "onPointerDown" | "onPointerDownCapture" | "onPointerMove" | "onPointerMoveCapture" | "onPointerUp" | "onPointerUpCapture" | "onPointerCancel" | "onPointerCancelCapture" | "onPointerEnter" | "onPointerEnterCapture" | "onPointerLeave" | "onPointerLeaveCapture" | "onPointerOver" | "onPointerOverCapture" | "onPointerOut" | "onPointerOutCapture" | "onGotPointerCapture" | "onGotPointerCaptureCapture" | "onLostPointerCapture" | "onLostPointerCaptureCapture" | "onScroll" | "onScrollCapture" | "onWheel" | "onWheelCapture" | "onAnimationStart" | "onAnimationStartCapture" | "onAnimationEnd" | "onAnimationEndCapture" | "onAnimationIteration" | "onAnimationIterationCapture" | "onTransitionEnd" | "onTransitionEndCapture" | "form" | "slot" | "title" | "pattern" | "dir" | "property" | "value" | "key" | "autoFocus" | "disabled" | "formAction" | "formEncType" | "formMethod" | "formNoValidate" | "formTarget" | "defaultChecked" | "defaultValue" | "suppressContentEditableWarning" | "suppressHydrationWarning" | "accessKey" | "contentEditable" | "contextMenu" | "draggable" | "hidden" | "placeholder" | "spellCheck" | "translate" | "radioGroup" | "about" | "datatype" | "inlist" | "prefix" | "resource" | "typeof" | "vocab" | "autoCapitalize" | "autoCorrect" | "autoSave" | "itemProp" | "itemScope" | "itemType" | "itemID" | "itemRef" | "results" | "security" | "unselectable" | "inputMode" | "is" | "list" | "step" | "accept" | "alt" | "autoComplete" | "capture" | "checked" | "maxLength" | "minLength" | "multiple" | "readOnly" | "required" | "src"> & {
    checked?: boolean;
    className?: string;
    disabled?: boolean;
    errorText?: string;
    id: string;
    label?: string | React.ReactNode;
    labelText?: string;
    onChange?: React.ChangeEventHandler<HTMLInputElement>;
    style?: React.CSSProperties;
    value?: string;
} & React.RefAttributes<HTMLInputElement>>;
type ColumnsProps = React.PropsWithChildren<{}>;
declare const Columns: ({ children }: ColumnsProps) => JSX.Element;
type ContainerProps = React.PropsWithChildren<React.HTMLProps<HTMLDivElement>>;
declare const Container: ({ children, className, ...rest }: ContainerProps) => JSX.Element;
type OptionType = {
    [key: string]: any;
};
type DropdownProps = {
    /**
     * Controls the circular keyboard navigation between items. If set to `true`, when first item is highlighted, the Arrow Up will move highlight to the last item, and vice versa using Arrow Down.
     */
    circularNavigation?: boolean;
    /**
     * Additional class names to apply to the dropdown
     */
    className?: string;
    /**
     * Close the menu when the user selects an option
     */
    closeMenuOnSelect?: boolean;
    /**
     * If `true`, the dropdown will be disabled
     */
    disabled?: boolean;
    /**
     * If `true`, the dropdown menu can be filtered
     */
    filterable?: boolean;
    /**
     * Function used to set the `id` prop for menu options (`li`). The returned `string` value will be set a the option `id`
     */
    getItemId?: (index: number) => string;
    /**
     * The helper text content that will be shown below the dropdown
     */
    helper?: string | React.ReactNode;
    /**
     * Hides the label above the dropdown
     */
    hideLabel?: boolean;
    /**
     * Item that should be selected when the dropdown is initialized
     */
    defaultValue?: OptionType;
    /**
     * Item(s) that should be selected when the dropdown is initialized. Use this instead of `defaultValue` when `multiselect` is enabled
     */
    defaultValues?: OptionType[];
    /**
     * Used to generate the first part of the id on the elements.
     * You can override this id with one of your own, provided as a prop, or you can override the id for each element using the `getItemId`, `labelId`, `inputId`, `menuId` and `toggleButtonId` props.
     */
    id?: string;
    /**
     * If `true`, the input and `helper` will be displayed in an invalid state
     */
    invalid?: boolean;
    /**
     * A function used to detect whether an option is disabled ([example](/?path=/story/components-dropdown--disabled-options))
     */
    isOptionDisabled?: (option: OptionType, index: number) => boolean;
    /**
     * Sets the data item field that represents the item label.
     * E.g. an `optionLabelField` value of `'foo'` and a data item `{ foo: 'Label', bar: 'value' }`, would display `Label` in the menu for that specific item
     */
    optionLabelField?: string;
    /**
     * Sets the `id` prop for the label element
     */
    labelId?: string;
    /**
     * The label for the dropdown
     */
    label?: string | React.ReactNode;
    /**
     * Sets the `id` prop for the input element when `filterable` is `true`
     */
    inputId?: string;
    /**
     * Sets the `id` prop for the menu (`ul`)
     */
    menuId?: string;
    /**
     * Enables selecting multiple values if `true`.
     *
     * Note: Using multiselect together with the `filterable` prop is not yet supported. `multiselect` will be ignored if `filterable` is `true`
     */
    multiselect?: boolean;
    /**
     * Callback fired when the state is changed
     */
    onChange?: (selectedItems: OptionType | OptionType[]) => void;
    /**
     * Array of options that should be shown in the menu
     */
    options: OptionType[];
    /**
     * Short hint displayed in the dropdown before the user enters a value
     */
    placeholder?: string;
    /**
     * If `true`, the label is displayed as required
     */
    required?: boolean;
    /**
     * The option(s) that should be selected
     */
    selectedOption?: OptionType | OptionType[];
    /**
     * Override or extend the root styles applied to the component
     */
    style?: React.CSSProperties;
    /**
     * Sets the `id` prop for the toggle button (`button`)
     */
    toggleButtonId?: string;
    /**
     * Sets the number of options that are visible in the menu before it becomes scrollable
     */
    visibleOptions?: number;
};
declare const Dropdown: ({ circularNavigation, className, closeMenuOnSelect, defaultValue, defaultValues, disabled, filterable, getItemId, helper, hideLabel, invalid, isOptionDisabled, label, labelId, id, inputId, menuId, multiselect, onChange, optionLabelField, options, placeholder, required, selectedOption, style, toggleButtonId, visibleOptions }: DropdownProps) => JSX.Element;
interface SelectCustomTheme {
    "--dropdown-background-default"?: string;
    "--dropdown-background-disabled"?: string;
    "--dropdown-border-color-default"?: string;
    "--dropdown-border-color-hover"?: string;
    "--dropdown-border-color-hover-invalid"?: string;
    "--dropdown-border-color-focus"?: string;
    "--dropdown-border-color-invalid"?: string;
    "--dropdown-border-color-disabled"?: string;
    "--dropdown-color-default"?: string;
    "--dropdown-color-disabled"?: string;
    "--focus-outline-color"?: string;
    "--helper-color-default"?: string;
    "--helper-color-invalid"?: string;
    "--menu-divider-color"?: string;
    "--menu-item-background-default"?: string;
    "--menu-item-background-hover"?: string;
    "--menu-item-background-selected"?: string;
    "--menu-item-background-selected-hover"?: string;
    "--menu-item-background-disabled"?: string;
    "--menu-item-color-default"?: string;
    "--menu-item-color-hover"?: string;
    "--menu-item-color-selected"?: string;
    "--menu-item-color-selected-hover"?: string;
    "--menu-item-color-disabled"?: string;
    "--menu-item-icon-color-selected"?: string;
    "--menu-item-icon-color-disabled"?: string;
    "--multiselect-checkbox-background-selected"?: string;
    "--multiselect-checkbox-background-disabled"?: string;
    "--multiselect-checkbox-border-default"?: string;
    "--multiselect-checkbox-border-hover"?: string;
    "--multiselect-checkbox-border-disabled"?: string;
    "--multiselect-checkbox-color-default"?: string;
    "--multiselect-checkbox-color-selected"?: string;
    "--multiselect-checkbox-color-selected-disabled"?: string;
    "--placeholder-color"?: string;
}
type CommonSelectProps<OptionType> = {
    /**
     * When `true`, allows moving from the first item to the last item with Arrow Up, and vice versa using Arrow Down.
     */
    circularNavigation?: boolean;
    /**
     * Additional class names to apply to the select
     */
    className?: string;
    /**
     * Flag for whether the clear selections button should be displayed
     */
    clearable?: boolean;
    /**
     * If `true`, the dropdown will be disabled
     */
    disabled?: boolean;
    /**
     * Function used to generate an ARIA a11y message when an item is selected. See [here](https://github.com/downshift-js/downshift/tree/master/src/hooks/useSelect#geta11yselectionmessage) for more information.
     */
    getA11ySelectionMessage?: (options: A11yStatusMessageOptions<OptionType>) => string;
    /**
     * Function used to generate an ARIA a11y message when the status changes. See [here](https://github.com/downshift-js/downshift/tree/master/src/hooks/useSelect#geta11ystatusmessage) for more information.
     */
    getA11yStatusMessage?: (options: A11yStatusMessageOptions<OptionType>) => string;
    /**
     * A helper text that will be shown below the dropdown
     */
    helper?: React.ReactNode;
    /**
     * An error text that will be shown below the dropdown when `invalid` is true
     */
    error?: React.ReactNode;
    /**
     * Used to generate the first part of the id on the elements
     */
    id?: string;
    /**
     * If `true`, the input and `helper` will be displayed in an invalid state
     */
    invalid?: boolean;
    /**
     * A function used to detect whether an option is disabled
     */
    isOptionDisabled?: (option: OptionType, index: number) => boolean;
    /**
     * The label for the dropdown
     */
    label: React.ReactNode;
    /**
     * Callback function fired when the state is changed
     */
    onBlur?: () => void;
    /**
     * Callback function fired when the component is focused
     */
    onFocus?: () => void;
    /**
     * Sets the data item field that represents the item label
     * E.g. an `optionLabelField` value of `'foo'` and a data item `{ foo: 'Label', bar: 'value' }`, would display `Label` in the menu for that specific item
     */
    optionLabelField?: string;
    /**
     * Array of options that should be shown in the menu
     */
    options: OptionType[];
    /**
     * Short hint displayed in the dropdown before the user enters a value
     */
    placeholder?: string;
    /**
     * If `true`, marks the dropdown as required
     */
    required?: boolean;
    /**
     * Override or extend the root styles applied to the component
     */
    style?: React.CSSProperties;
    /**
     * Custom theme styles
     */
    theme?: SelectCustomTheme;
    /**
     * If `true`, the menu options will be virtualized. This greatly increases performance when there are a lot of options,
     * but screen readers won't be able to know how many options there are.
     */
    virtualized?: boolean;
    /**
     * Sets the number of options that are visible in the menu before it becomes scrollable
     */
    visibleOptions?: number;
    /**
     * Aria-label text for the tooltip
     */
    tooltipLabel?: string;
    /**
     * Aria-label text for the tooltip trigger button
     */
    tooltipButtonLabel?: string;
    /**
     * The text content of the tooltip
     */
    tooltipText?: string;
};
type SingleSelectProps<OptionType> = CommonSelectProps<OptionType> & {
    /**
     * When `true`, enables selecting multiple values
     */
    multiselect?: false;
    /**
     * Value that should be selected when the dropdown is initialized
     */
    defaultValue?: OptionType;
    /**
     * Icon to be shown in the dropdown
     */
    icon?: React.ReactNode;
    /**
     * Callback function fired when the state is changed
     */
    onChange?: (selected: OptionType) => void;
    /**
     * The selected value
     */
    value?: OptionType;
};
type MultiSelectProps<OptionType> = CommonSelectProps<OptionType> & {
    /**
     * When `true`, enables selecting multiple values
     */
    multiselect: true;
    /**
     * The aria-label for the clear button
     */
    clearButtonAriaLabel: string;
    /**
     * Value(s) that should be selected when the dropdown is initialized
     */
    defaultValue?: OptionType[];
    /**
     * Function used to generate an ARIA a11y message when an item is removed. See [here](https://github.com/downshift-js/downshift/tree/master/src/hooks/useMultipleSelection#geta11yremovalmessage) for more information.
     */
    getA11yRemovalMessage?: (options: A11yRemovalMessage<OptionType>) => string;
    /**
     * Callback function fired when the state is changed
     */
    onChange?: (selected: OptionType[]) => void;
    /**
     * The aria-label for the selected item remove button.
     * You can use a special {value} token that will be replaced with the actual item value.
     * E.g. an item with the label Foo and property value of `'Remove ${value}'` would become `aria-label="Remove Foo"`.
     */
    selectedItemRemoveButtonAriaLabel: string;
    /**
     * A label for the selected items that is only visible to screen readers. Can be used to to give screen reader users additional information about the selected item.
     * You can use a special {value} token that will be replaced with the actual item value.
     * E.g. an item with the label Foo and property value of `'Selected item ${value}'` would become `aria-label="Selected item Foo"`.
     */
    selectedItemSrLabel?: string;
    /**
     * The selected value(s)
     */
    value?: OptionType[];
};
type SelectProps<OptionType> = SingleSelectProps<OptionType> | MultiSelectProps<OptionType>;
/**
 * Multi-select state change handler
 * @param type
 * @param activeIndex
 * @param currentActiveIndex
 * @param selectedItemsContainerEl
 */
declare function onMultiSelectStateChange<T>({ type, activeIndex }: UseMultipleSelectionStateChange<T>, currentActiveIndex: any, selectedItemsContainerEl: any): void;
/**
 * Multi-select reducer function
 * @param state
 * @param type
 * @param changes
 * @param controlled
 */
declare function multiSelectReducer<T>(state: UseMultipleSelectionState<T>, { type, changes }: UseMultipleSelectionStateChangeOptions<T>, controlled: boolean): Partial<UseMultipleSelectionState<T>>;
declare const Select: {
    <OptionType>(props: SelectProps<OptionType$0>): JSX.Element;
    defaultProps: {
        multiselect: boolean;
    };
};
type FilterFunction<OptionType> = (options: OptionType[], search: string) => OptionType[];
type ComboboxProps<OptionType> = SelectProps<OptionType> & {
    /**
     * Prevents further propagation of the 'Escape' onKeyDown event when the menu is closed by pressing Esc.
     * Useful e.g. when the component is used inside a modal.
     */
    catchEscapeKey?: boolean;
    /**
     * If provided, this filter function will be used for filtering the
     * combobox suggestions. If this prop is not provided, the default
     * filter implementation is used. The default implementation assumes
     * that the `optionLabelField` prop points to a string value that it
     * can compare with the search value.
     */
    filter?: FilterFunction<OptionType>;
    /**
     * If `true`, displays a menu toggle button in the combobox.
     */
    showToggleButton?: boolean;
    /**
     * aria-label for the menu toggle button. The label for the combobox will be prepended to the given value.
     */
    toggleButtonAriaLabel: string;
};
declare const Combobox: {
    <OptionType>(props: ComboboxProps<OptionType>): JSX.Element;
    defaultProps: {
        multiselect: boolean;
    };
};
type ErrorSummarySize = "default" | "large";
type ErrorSummaryProps = React.PropsWithChildren<{
    /**
     * Automatically focus the label of the error summary
     */
    autofocus?: boolean;
    /**
     * Additional class names to apply to the error summary
     */
    className?: string;
    /**
     * The label of the error summary.
     */
    label: string | React.ReactNode;
    /**
     * The size of the error summary
     */
    size?: ErrorSummarySize;
    /**
     * Override or extend the styles applied to the component
     */
    style?: React.CSSProperties;
}>;
declare const ErrorSummary: React.ForwardRefExoticComponent<{
    autofocus?: boolean;
    className?: string;
    label: string | React.ReactNode;
    size?: ErrorSummarySize;
    style?: React.CSSProperties;
} & {
    children?: React.ReactNode;
} & React.RefAttributes<HTMLDivElement>>;
type LogoLanguage = "fi" | "sv";
type LogoSize = "full" | "small" | "medium" | "large";
type LogoProps = React.ComponentPropsWithoutRef<"svg"> & {
    /**
     * Additional class names to apply to the logo
     */
    className?: string;
    /**
     * Adds a data-testid attribute to the root element with the given value
     */
    dataTestId?: string;
    /**
     * The language of the Helsinki-logo
     * @default 'fi'
     */
    language?: LogoLanguage;
    /**
     * The size of the logo
     * @default 'full'
     */
    size?: LogoSize;
    /**
     * Override or extend the styles applied to the component
     */
    style?: React.CSSProperties;
};
declare const Logo: ({ className, dataTestId, language, size, style, ...rest }: LogoProps) => JSX.Element;
type KorosType = "basic" | "beat" | "pulse" | "storm" | "wave";
type KorosProps = {
    /**
     * Whether the component should be flipped horizontally
     */
    flipHorizontal?: boolean;
    /**
     * Koros type
     */
    type?: KorosType;
    /**
     * Additional class names to apply to component
     */
    className?: string;
    /**
     * Additional style properties to apply to component
     */
    style?: React.CSSProperties;
};
declare const Koros: ({ flipHorizontal, type, className, style }: KorosProps) => JSX.Element;
type FooterReducerState = {
    /**
     * Defines how the navigation items will be displayed in the footer
     *
     * Supported values:
     *
     * `default` - Items will be displayed beneath the logo and title
     *
     * `minimal` - Items will be displayed inline with the logo and title. Intended to be used with 4 items or less.
     *
     * `sitemap` - Items will be displayed beneath the logo and title as groups with items and sub-items...
     */
    navigationVariant?: FooterNavigationVariant;
};
type FooterReducerAction = {
    type: "NAVIGATION_VARIANT";
    value: FooterNavigationVariant;
};
type FooterNavigationVariant = "default" | "minimal" | "sitemap";
type FooterTheme = "light" | "dark" | FooterCustomTheme;
interface FooterCustomTheme {
    "--footer-background"?: string;
    "--footer-color"?: string;
    "--footer-divider-color"?: string;
    "--footer-focus-outline-color"?: string;
}
type FooterProps = React.PropsWithChildren<{
    /**
     * Additional class names to apply to the footer
     */
    className?: string;
    /**
     * Props that will be passed to the native `<footer>` element
     */
    footerProps?: React.ComponentPropsWithoutRef<"footer">;
    /**
     * Koros type to use in the footer
     */
    korosType?: KorosType;
    /**
     * The language of the Helsinki-logo
     * @default 'fi'
     */
    logoLanguage?: LogoLanguage;
    /**
     * Defines the footer theme
     */
    theme?: FooterTheme;
    /**
     * The title of the service shown next to the logo
     */
    title?: React.ReactNode;
}>;
/**
 * Merges native element props and given type
 */
type MergeElementProps<T extends React.ElementType, P extends object = {}> = Omit<React.ComponentPropsWithoutRef<T>, keyof P> & P;
declare const Footer: {
    ({ children, className, footerProps, korosType, logoLanguage, theme, title }: FooterProps): JSX.Element;
    Navigation: {
        ({ children$0, navigationAriaLabel, variant }: React.PropsWithChildren<{
            navigationAriaLabel?: string;
            variant?: FooterNavigationVariant;
        }>): JSX.Element;
        componentName: string;
    };
    ItemGroup: ({ children }: {
        children?: React.ReactNode;
    }) => JSX.Element;
    Item: {
        <T extends React.ElementType<any> = "a">({ as, children$1, className$0, icon, label, subItem, ...rest }: MergeElementProps<T, React.PropsWithChildren<{
            as?: T;
            icon?: React.ReactNode;
            label?: React.ReactNode;
            subItem?: boolean;
        }>>): JSX.Element;
        defaultProps: {
            as: string;
        };
    };
    Utilities: ({ children, backToTopLabel, onBackToTopClick, showBackToTopButton }: React.PropsWithChildren<{
        backToTopLabel?: React.ReactNode;
        onBackToTopClick?: (event: React.MouseEvent<HTMLButtonElement, MouseEvent>) => void;
        showBackToTopButton?: boolean;
    }>) => JSX.Element;
    SoMe: {
        ({ children$2, soMeSectionProps }: React.PropsWithChildren<{
            soMeSectionProps?: Pick<React.DetailedHTMLProps<React.HTMLAttributes<HTMLElement>, HTMLElement>, "className" | "style" | "color" | "id" | "lang" | "role" | "tabIndex" | "aria-activedescendant" | "aria-atomic" | "aria-autocomplete" | "aria-busy" | "aria-checked" | "aria-colcount" | "aria-colindex" | "aria-colspan" | "aria-controls" | "aria-current" | "aria-describedby" | "aria-details" | "aria-disabled" | "aria-dropeffect" | "aria-errormessage" | "aria-expanded" | "aria-flowto" | "aria-grabbed" | "aria-haspopup" | "aria-hidden" | "aria-invalid" | "aria-keyshortcuts" | "aria-label" | "aria-labelledby" | "aria-level" | "aria-live" | "aria-modal" | "aria-multiline" | "aria-multiselectable" | "aria-orientation" | "aria-owns" | "aria-placeholder" | "aria-posinset" | "aria-pressed" | "aria-readonly" | "aria-relevant" | "aria-required" | "aria-roledescription" | "aria-rowcount" | "aria-rowindex" | "aria-rowspan" | "aria-selected" | "aria-setsize" | "aria-sort" | "aria-valuemax" | "aria-valuemin" | "aria-valuenow" | "aria-valuetext" | "children" | "dangerouslySetInnerHTML" | "onCopy" | "onCopyCapture" | "onCut" | "onCutCapture" | "onPaste" | "onPasteCapture" | "onCompositionEnd" | "onCompositionEndCapture" | "onCompositionStart" | "onCompositionStartCapture" | "onCompositionUpdate" | "onCompositionUpdateCapture" | "onFocus" | "onFocusCapture" | "onBlur" | "onBlurCapture" | "onChange" | "onChangeCapture" | "onBeforeInput" | "onBeforeInputCapture" | "onInput" | "onInputCapture" | "onReset" | "onResetCapture" | "onSubmit" | "onSubmitCapture" | "onInvalid" | "onInvalidCapture" | "onLoad" | "onLoadCapture" | "onError" | "onErrorCapture" | "onKeyDown" | "onKeyDownCapture" | "onKeyPress" | "onKeyPressCapture" | "onKeyUp" | "onKeyUpCapture" | "onAbort" | "onAbortCapture" | "onCanPlay" | "onCanPlayCapture" | "onCanPlayThrough" | "onCanPlayThroughCapture" | "onDurationChange" | "onDurationChangeCapture" | "onEmptied" | "onEmptiedCapture" | "onEncrypted" | "onEncryptedCapture" | "onEnded" | "onEndedCapture" | "onLoadedData" | "onLoadedDataCapture" | "onLoadedMetadata" | "onLoadedMetadataCapture" | "onLoadStart" | "onLoadStartCapture" | "onPause" | "onPauseCapture" | "onPlay" | "onPlayCapture" | "onPlaying" | "onPlayingCapture" | "onProgress" | "onProgressCapture" | "onRateChange" | "onRateChangeCapture" | "onSeeked" | "onSeekedCapture" | "onSeeking" | "onSeekingCapture" | "onStalled" | "onStalledCapture" | "onSuspend" | "onSuspendCapture" | "onTimeUpdate" | "onTimeUpdateCapture" | "onVolumeChange" | "onVolumeChangeCapture" | "onWaiting" | "onWaitingCapture" | "onAuxClick" | "onAuxClickCapture" | "onClick" | "onClickCapture" | "onContextMenu" | "onContextMenuCapture" | "onDoubleClick" | "onDoubleClickCapture" | "onDrag" | "onDragCapture" | "onDragEnd" | "onDragEndCapture" | "onDragEnter" | "onDragEnterCapture" | "onDragExit" | "onDragExitCapture" | "onDragLeave" | "onDragLeaveCapture" | "onDragOver" | "onDragOverCapture" | "onDragStart" | "onDragStartCapture" | "onDrop" | "onDropCapture" | "onMouseDown" | "onMouseDownCapture" | "onMouseEnter" | "onMouseLeave" | "onMouseMove" | "onMouseMoveCapture" | "onMouseOut" | "onMouseOutCapture" | "onMouseOver" | "onMouseOverCapture" | "onMouseUp" | "onMouseUpCapture" | "onSelect" | "onSelectCapture" | "onTouchCancel" | "onTouchCancelCapture" | "onTouchEnd" | "onTouchEndCapture" | "onTouchMove" | "onTouchMoveCapture" | "onTouchStart" | "onTouchStartCapture" | "onPointerDown" | "onPointerDownCapture" | "onPointerMove" | "onPointerMoveCapture" | "onPointerUp" | "onPointerUpCapture" | "onPointerCancel" | "onPointerCancelCapture" | "onPointerEnter" | "onPointerEnterCapture" | "onPointerLeave" | "onPointerLeaveCapture" | "onPointerOver" | "onPointerOverCapture" | "onPointerOut" | "onPointerOutCapture" | "onGotPointerCapture" | "onGotPointerCaptureCapture" | "onLostPointerCapture" | "onLostPointerCaptureCapture" | "onScroll" | "onScrollCapture" | "onWheel" | "onWheelCapture" | "onAnimationStart" | "onAnimationStartCapture" | "onAnimationEnd" | "onAnimationEndCapture" | "onAnimationIteration" | "onAnimationIterationCapture" | "onTransitionEnd" | "onTransitionEndCapture" | "slot" | "title" | "dir" | "property" | "key" | "defaultChecked" | "defaultValue" | "suppressContentEditableWarning" | "suppressHydrationWarning" | "accessKey" | "contentEditable" | "contextMenu" | "draggable" | "hidden" | "placeholder" | "spellCheck" | "translate" | "radioGroup" | "about" | "datatype" | "inlist" | "prefix" | "resource" | "typeof" | "vocab" | "autoCapitalize" | "autoCorrect" | "autoSave" | "itemProp" | "itemScope" | "itemType" | "itemID" | "itemRef" | "results" | "security" | "unselectable" | "inputMode" | "is">;
        }>): JSX.Element;
        componentName: string;
    };
    Base: ({ children, copyrightHolder, copyrightText }: React.PropsWithChildren<{
        copyrightHolder?: React.ReactNode;
        copyrightText?: React.ReactNode;
    }>) => JSX.Element;
};
type ImageWithCardAlignment = "left" | "right";
type ImageWithCardLayout = "hover" | "split";
type ImageWithCardColor = "primary" | "secondary" | "tertiary" | "plain";
type ImageWithCardProps = React.PropsWithChildren<{
    src: string;
    fullWidth?: boolean;
    cardAlignment?: ImageWithCardAlignment;
    cardLayout?: ImageWithCardLayout;
    color?: ImageWithCardColor;
    className?: string;
}>;
declare const ImageWithCard: ({ src, fullWidth, children, cardAlignment, color, cardLayout, className }: ImageWithCardProps) => JSX.Element;
interface LoadingSpinnerCustomTheme {
    "--spinner-color"?: string;
    "--spinner-color-stage1"?: string;
    "--spinner-color-stage2"?: string;
    "--spinner-color-stage3"?: string;
}
type LoadingSpinnerProps = {
    /**
     * Additional class names for loading spinner.
     */
    className?: string;
    /**
     * If `true`, the multicolor variant is used.
     * @default false
     */
    multicolor?: boolean;
    /**
     * If `true`, the small variant is used.
     * @default false
     */
    small?: boolean;
    /**
     * Custom theme
     */
    theme?: LoadingSpinnerCustomTheme;
    /**
     * Text to show for screen readers when spinner is visible.
     * @default "Page is loading"
     */
    loadingText?: string;
    /**
     * Text to show for screen readers when spinner is removed.
     * @default "Page has finished loading"
     */
    loadingFinishedText?: string;
    /**
     * Value for aria-valuenow attribute. Required unless the loading status is indeterminate.
     */
    valuenow?: number;
} & React.HTMLProps<HTMLDivElement>;
declare const LoadingSpinner: ({ className, multicolor, small, theme, loadingText, loadingFinishedText, ...rest }: LoadingSpinnerProps) => JSX.Element;
type NavigationVariant = "default" | "inline";
type NavigationTheme = "light" | "dark" | NavigationCustomTheme;
interface NavigationCustomTheme {
    "--header-background-color"?: string;
    "--header-color"?: string;
    "--header-divider-color"?: string;
    "--header-focus-outline-color"?: string;
    "--mobile-menu-background-color"?: string;
    "--mobile-menu-color"?: string;
    "--navigation-row-background-color"?: string;
    "--navigation-row-color"?: string;
    "--navigation-row-focus-outline-color"?: string;
}
type NavigationProps = React.PropsWithChildren<{
    /**
     * Additional class names to apply to the navigation
     */
    className?: string;
    /**
     * If `true`, the navigation will be fixed to the top of the page
     * @default false
     */
    fixed?: boolean;
    /**
     * ID of the header element
     */
    id?: string;
    /**
     * The language of the Helsinki-logo
     * @default 'fi'
     */
    logoLanguage?: LogoLanguage;
    /**
     * Sets whether the mobile menu is open. Used together with the `onMenuToggle` prop to override the internal state handling
     * @default false
     */
    menuOpen?: boolean;
    /**
     * aria-label for the mobile menu toggle button
     */
    menuToggleAriaLabel: string;
    /**
     * Callback fired when the mobile menu is toggled. Can be used together with the `menuOpen` prop to override the internal state handling
     */
    onMenuToggle?: () => void;
    /**
     * Callback fired when the title or logo is clicked
     */
    onTitleClick?: () => void;
    /**
     * ID of the element to jump to when the "skip to content" accessibility shortcut is clicked
     */
    skipTo: string;
    /**
     * aria-label for the "skip to content" accessibility shortcut
     */
    skipToContentAriaLabel?: string;
    /**
     * Text for the "skip to content" accessibility shortcut
     */
    skipToContentLabel: React.ReactNode;
    /**
     * Defines the navigation theme
     * @default 'white'
     */
    theme?: NavigationTheme;
    /**
     * The title of the service shown next to the logo
     */
    title?: React.ReactNode;
    /**
     * The aria-label for the title describing the logo and service to screen reader users
     */
    titleAriaLabel?: React.ReactNode;
    /**
     * URL to navigate to when the logo or title is clicked
     */
    titleUrl?: string;
}>;
type MenuButtonProps = React.PropsWithChildren<{
    /**
     * aria-label for the dropdown toggle button
     */
    buttonAriaLabel?: string;
    /**
     * Additional class names to apply to the dropdown
     */
    className?: string;
    /**
     * Should the menu close after item is clicked
     */
    closeOnItemClick?: boolean;
    /**
     * Used to generate the first part of the id on the elements
     */
    id?: string;
    /**
     * Icon to be displayed in the dropdown
     */
    icon?: React.ReactNode;
    /**
     * Label for the dropdown
     */
    label: React.ReactNode;
    /**
     * Spacing between the toggle button and the menu
     */
    menuOffset?: number;
}>;
type NavigationDropdownProps = MenuButtonProps & {
    /**
     * If `true`, the item will be marked as active
     */
    active?: boolean;
};
type ItemProps = {
    /**
     * If `true`, the item will be marked as active
     */
    active?: boolean;
    /**
     * Icon placed on the left side of the item label
     */
    icon?: React.ReactNode;
    /**
     * The label for the item. Optionally, children can be passed
     */
    label?: React.ReactNode;
    /**
     * Defines the button variant in mobile view. Intended to be used within the `NavigationUser` component
     */
    variant?: "primary" | "secondary";
};
type SupplementaryItemProps = Omit<ItemProps, "variant"> & {
    variant: "supplementary";
    icon: React.ReactNode;
};
type NavigationItemProps<Element extends React.ElementType = "a"> = {
    /**
     * Element type
     */
    as?: Element;
} & MergeElementProps<Element, ItemProps | SupplementaryItemProps>;
type NavigationSearchProps = {
    /**
     * Callback fired when the search field is blurred
     */
    onBlur?: () => void;
    /**
     * Callback fired when the search field is focused
     */
    onFocus?: () => void;
    /**
     * Callback fired when the search button or Enter key is pressed
     */
    onSearch?: (inputValue: string, event: React.MouseEvent<HTMLButtonElement> | React.KeyboardEvent<HTMLInputElement>) => void;
    /**
     * Callback fired when the search input value is changed
     */
    onSearchChange?: (inputValue: string, event: React.ChangeEvent<HTMLInputElement>) => void;
    /**
     * The aria-label for the search button. Uses `searchLabel` by default
     */
    searchButtonAriaLabel?: string;
    /**
     * Label shown when search field isn't active
     */
    searchLabel: string;
    /**
     * Placeholder text shown in the search input field. Uses the `searchLabel` value by default
     */
    searchPlaceholder?: string;
};
type NavigationUserProps = MenuButtonProps & {
    /**
     * Flag for whether the user is authenticated
     */
    authenticated?: boolean;
    /**
     * Label for the "Sign in" button
     */
    label: React.ReactNode;
    /**
     * Callback fired when the "Sign in" button is clicked
     */
    onSignIn?: () => void;
    /**
     * Name of the user displayed in the dropdown
     */
    userName?: React.ReactNode;
};
declare const Navigation: {
    ({ children$6, className$2, fixed, id$0, logoLanguage$0, menuOpen, menuToggleAriaLabel, onMenuToggle, onTitleClick, skipTo, skipToContentAriaLabel, skipToContentLabel, theme$0, title$0, titleAriaLabel, titleUrl }: NavigationProps): JSX.Element;
    Actions: {
        ({ children$7 }: {
            children?: React.ReactNode;
        }): JSX.Element;
        componentName: string;
    };
    Dropdown: {
        ({ label$3, children$8, ...rest$2 }: NavigationDropdownProps): JSX.Element;
        componentName: string;
    };
    Item: {
        <T extends React.ElementType<any> = "a">({ active, as, children$9, className$3, icon, label$4, variant, ...rest$3 }: NavigationItemProps<T>): JSX.Element;
        defaultProps: {
            as: string;
        };
    };
    LanguageSelector: {
        ({ children$10, id$1, label$5, ...rest$4 }: React.PropsWithChildren<{
            buttonAriaLabel?: string;
            className?: string;
            closeOnItemClick?: boolean;
            id?: string;
            icon?: React.ReactNode;
            label: React.ReactNode;
            menuOffset?: number;
        }>): JSX.Element;
        componentName: string;
    };
    Row: {
        ({ variant$0, children$11 }: React.PropsWithChildren<{
            variant?: NavigationVariant;
        }>): JSX.Element;
        componentName: string;
    };
    Search: {
        ({ onBlur, onFocus, onSearchChange, onSearch, searchButtonAriaLabel, searchLabel, searchPlaceholder }: NavigationSearchProps): JSX.Element;
        componentName: string;
    };
    User: {
        ({ authenticated, children$12, id$2, label$6, onSignIn, userName, ...dropdownProps }: NavigationUserProps): JSX.Element;
        componentName: string;
    };
};
type NotificationType = "info" | "error" | "alert" | "success";
type NotificationSizeInline = "default" | "small" | "large";
type NotificationSizeToast = Exclude<NotificationSizeInline, "large">;
type NotificationPosition = "inline" | "top-left" | "top-center" | "top-right" | "bottom-left" | "bottom-center" | "bottom-right";
type CommonProps = React.PropsWithChildren<{
    /**
     * Whether the notification should be closed automatically after a certain time
     * @default false
     */
    autoClose?: boolean;
    /**
     * The duration before the notification is automatically closed. Used together with the `autoClose` prop.
     * @default 6000
     */
    autoCloseDuration?: number;
    /**
     * Additional class names to apply to the notification
     */
    className?: string;
    /**
     * Duration of the close fade-out animation
     * @default 85
     */
    closeAnimationDuration?: number;
    /**
     * Value for the data-testid attribute that is applied to the root component.
     */
    dataTestId?: string;
    /**
     * Displays a progress bar on top of the notification when `true`
     * @default true
     */
    displayAutoCloseProgress?: boolean;
    /**
     * Determines whether the notification should be visually hidden. Useful when notification should only be "seen" by screen readers.
     * @default false
     */
    invisible?: boolean;
    /**
     * The label of the notification.
     * Note: Labels are not displayed visually for small notifications, but they are still accessible to assistive technology. This could be used to help screen reader users to better understand the context of the notification.
     */
    label?: string | React.ReactNode;
    /**
     * Callback fired when the notification is closed
     */
    onClose?: () => void;
    /**
     * Override or extend the styles applied to the component
     */
    style?: React.CSSProperties;
    /**
     * The type of the notification
     * @default 'info'
     */
    type?: NotificationType;
}>;
type PositionAndSize = {
    position?: "inline";
    size?: NotificationSizeInline;
} | {
    /**
     * The position of the notification
     */
    position?: NotificationPosition;
    /**
     * The size of the notification
     */
    size?: NotificationSizeToast;
};
type Dismissible = {
    dismissible?: false;
    closeButtonLabelText?: string;
} | {
    /**
     * Whether the notification can be closed
     * @default false
     */
    dismissible?: boolean;
    /**
     * The aria-label and title for the close button
     */
    closeButtonLabelText: string;
};
type NotificationProps = CommonProps & PositionAndSize & Dismissible;
declare const Notification: React.ForwardRefExoticComponent<({
    autoClose?: boolean;
    autoCloseDuration?: number;
    className?: string;
    closeAnimationDuration?: number;
    dataTestId?: string;
    displayAutoCloseProgress?: boolean;
    invisible?: boolean;
    label?: string | React.ReactNode;
    onClose?: () => void;
    style?: React.CSSProperties;
    type?: NotificationType;
} & {
    children?: React.ReactNode;
} & {
    position?: "inline";
    size?: NotificationSizeInline;
} & {
    dismissible?: false;
    closeButtonLabelText?: string;
} & React.RefAttributes<HTMLDivElement>) | ({
    autoClose?: boolean;
    autoCloseDuration?: number;
    className?: string;
    closeAnimationDuration?: number;
    dataTestId?: string;
    displayAutoCloseProgress?: boolean;
    invisible?: boolean;
    label?: string | React.ReactNode;
    onClose?: () => void;
    style?: React.CSSProperties;
    type?: NotificationType;
} & {
    children?: React.ReactNode;
} & {
    position?: "inline";
    size?: NotificationSizeInline;
} & {
    dismissible?: boolean;
    closeButtonLabelText: string;
} & React.RefAttributes<HTMLDivElement>) | ({
    autoClose?: boolean;
    autoCloseDuration?: number;
    className?: string;
    closeAnimationDuration?: number;
    dataTestId?: string;
    displayAutoCloseProgress?: boolean;
    invisible?: boolean;
    label?: string | React.ReactNode;
    onClose?: () => void;
    style?: React.CSSProperties;
    type?: NotificationType;
} & {
    children?: React.ReactNode;
} & {
    position?: NotificationPosition;
    size?: NotificationSizeToast;
} & {
    dismissible?: false;
    closeButtonLabelText?: string;
} & React.RefAttributes<HTMLDivElement>) | ({
    autoClose?: boolean;
    autoCloseDuration?: number;
    className?: string;
    closeAnimationDuration?: number;
    dataTestId?: string;
    displayAutoCloseProgress?: boolean;
    invisible?: boolean;
    label?: string | React.ReactNode;
    onClose?: () => void;
    style?: React.CSSProperties;
    type?: NotificationType;
} & {
    children?: React.ReactNode;
} & {
    position?: NotificationPosition;
    size?: NotificationSizeToast;
} & {
    dismissible?: boolean;
    closeButtonLabelText: string;
} & React.RefAttributes<HTMLDivElement>)>;
type RadioButtonProps = React.ComponentPropsWithoutRef<"input"> & {
    /**
     * If `true`, the component is checked
     */
    checked?: boolean;
    /**
     * Additional class names to apply to the radio button
     */
    className?: string;
    /**
     * If `true`, the radio button will be disabled
     */
    disabled?: boolean;
    /**
     * The id of the input element
     */
    id: string;
    /**
     * The label for the radio button
     */
    label?: string | React.ReactNode;
    /**
     * **[DEPRECATED]** This prop will be removed in a future version. Use the `label` prop instead
     * @deprecated
     */
    labelText?: string;
    /**
     * Callback fired when the state is changed
     */
    onChange?: React.ChangeEventHandler<HTMLInputElement>;
    /**
     * Override or extend the styles applied to the component
     */
    style?: React.CSSProperties;
    /**
     * The value of the component
     */
    value?: string;
};
declare const RadioButton: React.ForwardRefExoticComponent<Pick<React.DetailedHTMLProps<React.InputHTMLAttributes<HTMLInputElement>, HTMLInputElement>, "size" | "className" | "style" | "color" | "height" | "id" | "lang" | "max" | "min" | "name" | "type" | "width" | "role" | "tabIndex" | "crossOrigin" | "aria-activedescendant" | "aria-atomic" | "aria-autocomplete" | "aria-busy" | "aria-checked" | "aria-colcount" | "aria-colindex" | "aria-colspan" | "aria-controls" | "aria-current" | "aria-describedby" | "aria-details" | "aria-disabled" | "aria-dropeffect" | "aria-errormessage" | "aria-expanded" | "aria-flowto" | "aria-grabbed" | "aria-haspopup" | "aria-hidden" | "aria-invalid" | "aria-keyshortcuts" | "aria-label" | "aria-labelledby" | "aria-level" | "aria-live" | "aria-modal" | "aria-multiline" | "aria-multiselectable" | "aria-orientation" | "aria-owns" | "aria-placeholder" | "aria-posinset" | "aria-pressed" | "aria-readonly" | "aria-relevant" | "aria-required" | "aria-roledescription" | "aria-rowcount" | "aria-rowindex" | "aria-rowspan" | "aria-selected" | "aria-setsize" | "aria-sort" | "aria-valuemax" | "aria-valuemin" | "aria-valuenow" | "aria-valuetext" | "children" | "dangerouslySetInnerHTML" | "onCopy" | "onCopyCapture" | "onCut" | "onCutCapture" | "onPaste" | "onPasteCapture" | "onCompositionEnd" | "onCompositionEndCapture" | "onCompositionStart" | "onCompositionStartCapture" | "onCompositionUpdate" | "onCompositionUpdateCapture" | "onFocus" | "onFocusCapture" | "onBlur" | "onBlurCapture" | "onChange" | "onChangeCapture" | "onBeforeInput" | "onBeforeInputCapture" | "onInput" | "onInputCapture" | "onReset" | "onResetCapture" | "onSubmit" | "onSubmitCapture" | "onInvalid" | "onInvalidCapture" | "onLoad" | "onLoadCapture" | "onError" | "onErrorCapture" | "onKeyDown" | "onKeyDownCapture" | "onKeyPress" | "onKeyPressCapture" | "onKeyUp" | "onKeyUpCapture" | "onAbort" | "onAbortCapture" | "onCanPlay" | "onCanPlayCapture" | "onCanPlayThrough" | "onCanPlayThroughCapture" | "onDurationChange" | "onDurationChangeCapture" | "onEmptied" | "onEmptiedCapture" | "onEncrypted" | "onEncryptedCapture" | "onEnded" | "onEndedCapture" | "onLoadedData" | "onLoadedDataCapture" | "onLoadedMetadata" | "onLoadedMetadataCapture" | "onLoadStart" | "onLoadStartCapture" | "onPause" | "onPauseCapture" | "onPlay" | "onPlayCapture" | "onPlaying" | "onPlayingCapture" | "onProgress" | "onProgressCapture" | "onRateChange" | "onRateChangeCapture" | "onSeeked" | "onSeekedCapture" | "onSeeking" | "onSeekingCapture" | "onStalled" | "onStalledCapture" | "onSuspend" | "onSuspendCapture" | "onTimeUpdate" | "onTimeUpdateCapture" | "onVolumeChange" | "onVolumeChangeCapture" | "onWaiting" | "onWaitingCapture" | "onAuxClick" | "onAuxClickCapture" | "onClick" | "onClickCapture" | "onContextMenu" | "onContextMenuCapture" | "onDoubleClick" | "onDoubleClickCapture" | "onDrag" | "onDragCapture" | "onDragEnd" | "onDragEndCapture" | "onDragEnter" | "onDragEnterCapture" | "onDragExit" | "onDragExitCapture" | "onDragLeave" | "onDragLeaveCapture" | "onDragOver" | "onDragOverCapture" | "onDragStart" | "onDragStartCapture" | "onDrop" | "onDropCapture" | "onMouseDown" | "onMouseDownCapture" | "onMouseEnter" | "onMouseLeave" | "onMouseMove" | "onMouseMoveCapture" | "onMouseOut" | "onMouseOutCapture" | "onMouseOver" | "onMouseOverCapture" | "onMouseUp" | "onMouseUpCapture" | "onSelect" | "onSelectCapture" | "onTouchCancel" | "onTouchCancelCapture" | "onTouchEnd" | "onTouchEndCapture" | "onTouchMove" | "onTouchMoveCapture" | "onTouchStart" | "onTouchStartCapture" | "onPointerDown" | "onPointerDownCapture" | "onPointerMove" | "onPointerMoveCapture" | "onPointerUp" | "onPointerUpCapture" | "onPointerCancel" | "onPointerCancelCapture" | "onPointerEnter" | "onPointerEnterCapture" | "onPointerLeave" | "onPointerLeaveCapture" | "onPointerOver" | "onPointerOverCapture" | "onPointerOut" | "onPointerOutCapture" | "onGotPointerCapture" | "onGotPointerCaptureCapture" | "onLostPointerCapture" | "onLostPointerCaptureCapture" | "onScroll" | "onScrollCapture" | "onWheel" | "onWheelCapture" | "onAnimationStart" | "onAnimationStartCapture" | "onAnimationEnd" | "onAnimationEndCapture" | "onAnimationIteration" | "onAnimationIterationCapture" | "onTransitionEnd" | "onTransitionEndCapture" | "form" | "slot" | "title" | "pattern" | "dir" | "property" | "value" | "key" | "autoFocus" | "disabled" | "formAction" | "formEncType" | "formMethod" | "formNoValidate" | "formTarget" | "defaultChecked" | "defaultValue" | "suppressContentEditableWarning" | "suppressHydrationWarning" | "accessKey" | "contentEditable" | "contextMenu" | "draggable" | "hidden" | "placeholder" | "spellCheck" | "translate" | "radioGroup" | "about" | "datatype" | "inlist" | "prefix" | "resource" | "typeof" | "vocab" | "autoCapitalize" | "autoCorrect" | "autoSave" | "itemProp" | "itemScope" | "itemType" | "itemID" | "itemRef" | "results" | "security" | "unselectable" | "inputMode" | "is" | "list" | "step" | "accept" | "alt" | "autoComplete" | "capture" | "checked" | "maxLength" | "minLength" | "multiple" | "readOnly" | "required" | "src"> & {
    checked?: boolean;
    className?: string;
    disabled?: boolean;
    id: string;
    label?: string | React.ReactNode;
    labelText?: string;
    onChange?: React.ChangeEventHandler<HTMLInputElement>;
    style?: React.CSSProperties;
    value?: string;
} & React.RefAttributes<HTMLInputElement>>;
type GetSuggestionsFunction<SuggestionItemType> = (searchString: string) => Promise<SuggestionItemType[]>;
type SearchInputProps<SuggestionItem> = {
    /**
     * Additional class names to add to the component
     */
    className?: string;
    /**
     * The aria-label for the clear button.
     * @default Clear
     */
    clearButtonAriaLabel?: string;
    /**
     * Callback function fired every time the input content changes. Receives the input value as a parameter. Must return a promise which resolves to an array of SuggestionItems.
     */
    getSuggestions?: GetSuggestionsFunction<SuggestionItem>;
    /**
     * The helper text content that will be shown below the input
     */
    helperText?: string;
    /**
     * Should the matching part of a suggestion be highlighted.
     * @default true
     */
    highlightSuggestions?: boolean;
    /**
     * The label for the search field
     */
    label: React.ReactNode;
    /**
     * Text to show for screen readers when loading spinner is no longer visible.
     * @default "Finished loading suggestions"
     */
    loadingSpinnerFinishedText?: string;
    /**
     * Text to show for screen readers when loading spinner is visible.
     * @default "Loading suggestions"
     */
    loadingSpinnerText?: string;
    /**
     * Callback function fired after search is triggered.
     */
    onSubmit: (value: string) => void;
    /**
     * The aria-label for the search button.
     * @default Search
     */
    searchButtonAriaLabel?: string;
    /**
     * Override or extend the styles applied to the component
     */
    style?: React.CSSProperties;
    /**
     * Field of the SuggestionItem that represents the item label.
     * E.g. an `suggestionLabelField` value of `'foo'` and a suggestion item `{ foo: 'Label', bar: 'value' }`, would display `'Label'` in the menu for that specific suggestion.
     */
    suggestionLabelField?: keyof SuggestionItem;
    /**
     * The number of suggestions that are visible in the menu before it becomes scrollable.
     * @default 8
     */
    visibleSuggestions?: number;
};
declare const SearchInput: <SuggestionItem>({ className, clearButtonAriaLabel, getSuggestions, helperText, highlightSuggestions, label, loadingSpinnerFinishedText, loadingSpinnerText, onSubmit, searchButtonAriaLabel, style, suggestionLabelField, visibleSuggestions }: SearchInputProps<SuggestionItem>) => JSX.Element;
type SectionColor = "primary" | "secondary" | "tertiary" | "plain";
type SectionProps = React.PropsWithChildren<{
    color?: SectionColor;
    className?: string;
    korosType?: KorosType;
}>;
declare const Section: ({ children, className, color, korosType }: SectionProps) => JSX.Element;
type Direction = "vertical" | "horizontal";
type SelectionGroupProps = React.PropsWithChildren<{
    /**
     * The label for the selection group.
     */
    label?: string;
    /**
     * The direction in which child components should be rendered in.
     */
    direction?: Direction;
    /**
     * The error text content that will be shown below the selection group
     */
    errorText?: string;
    /**
     * If `true`, the label is displayed as required.
     */
    required?: boolean;
    /**
     * Aria-label text for the tooltip
     */
    tooltipLabel?: string;
    /**
     * Aria-label text for the tooltip trigger button
     */
    tooltipButtonLabel?: string;
    /**
     * The text content of the tooltip
     */
    tooltipText?: string;
    /**
     * Additional class names
     */
    className?: string;
} & React.HTMLProps<HTMLFieldSetElement>>;
declare const SelectionGroup: ({ label, direction, errorText, required, tooltipLabel, tooltipButtonLabel, tooltipText, children, className, ...fieldSetProps }: SelectionGroupProps) => JSX.Element;
type StatusLabelType = "neutral" | "info" | "success" | "alert" | "error";
type StatusLabelProps = React.PropsWithChildren<{
    /**
     * Additional class names to apply to the status label
     */
    className?: string;
    /**
     * Adds a data-testid attribute to the root element with the given value
     */
    dataTestId?: string;
    /**
     * The type of the status label
     */
    type?: StatusLabelType;
}>;
declare const StatusLabel: ({ children, className, dataTestId, type, ...rest }: StatusLabelProps) => JSX.Element;
interface TagCustomTheme {
    "--tag-background"?: string;
    "--tag-color"?: string;
    "--tag-focus-outline-color"?: string;
}
type TagProps = {
    /**
     * The label for the tag
     */
    children: React.ReactNode;
    /**
     * Additional class names to apply to the tag
     */
    className?: string;
    /**
     * The aria-label for the delete button
     */
    deleteButtonAriaLabel?: string;
    /**
     * Props that will be passed to the delete button `<button>` element.
     */
    deleteButtonProps?: React.ComponentPropsWithoutRef<"button">;
    /**
     * Used to generate the first part of the id on the elements.
     */
    id?: string;
    /**
     * Props that will be passed to the label `<span>` element.
     */
    labelProps?: React.ComponentPropsWithoutRef<"span">;
    /**
     * Callback function fired when the tag is clicked. If set, the tag will be clickable.
     */
    onClick?: (event: React.MouseEvent<HTMLDivElement, MouseEvent> | React.KeyboardEvent<HTMLDivElement>) => void;
    /**
     * Callback function fired when the delete icon is clicked. If set, a delete button will be shown.
     */
    onDelete?: (event: React.MouseEvent<HTMLButtonElement, MouseEvent>) => void;
    /**
     * Sets the role of the tag when it's clickable. Uses 'link' by default.
     */
    role?: "link" | "button";
    /**
     * Label that is only visible to screen readers. Can be used to to give screen reader users additional information about the tag.
     */
    srOnlyLabel?: string;
    /**
     * Custom theme styles
     */
    theme?: TagCustomTheme;
};
declare const Tag: React.ForwardRefExoticComponent<TagProps & React.RefAttributes<HTMLDivElement>>;
type TextAreaProps = React.ComponentPropsWithoutRef<"textarea"> & {
    /**
     * Additional class names to apply to the textarea
     */
    className?: string;
    /**
     * The default textarea element value. Use when the component is not controlled
     */
    defaultValue?: string;
    /**
     * If `true`, the textarea will be disabled
     */
    disabled?: boolean;
    /**
     * The error text content that will be shown below the textarea
     */
    errorText?: string;
    /**
     * The helper text content that will be shown below the textarea
     */
    helperText?: string;
    /**
     * Hides the label above the textarea
     */
    hideLabel?: boolean;
    /**
     * The id of the textarea element
     */
    id: string;
    /**
     * If `true`, the textarea and `helperText` will be displayed in an invalid state.
     */
    invalid?: boolean;
    /**
     * The label for the textarea
     */
    label?: string | React.ReactNode;
    /**
     * **[DEPRECATED]** This prop will be removed in a future version. Use the `label` prop instead
     */
    labelText?: string;
    /**
     * Callback fired when the state is changed
     */
    onChange?: React.ChangeEventHandler<HTMLTextAreaElement>;
    /**
     * Short hint displayed in the textarea before the user enters a value
     */
    placeholder?: string;
    /**
     * If `true`, the label is displayed as required and the `textarea` element will be required
     */
    required?: boolean;
    /**
     * Override or extend the styles applied to the component. See text field [tokens](https://city-of-helsinki.github.io/helsinki-design-system/components/text-field#tokens) for available CSS variables
     */
    style?: React.CSSProperties;
    /**
     * The success text content that will be shown below the text area
     */
    successText?: string;
    /**
     * Aria-label text for the tooltip
     */
    tooltipLabel?: string;
    /**
     * Aria-label text for the tooltip trigger button
     */
    tooltipButtonLabel?: string;
    /**
     * The text content of the tooltip
     */
    tooltipText?: string;
    /**
     * The value of the textarea element, required for a controlled component
     */
    value?: string;
    /**
     * The `ref` is forwarded to the native textarea element.
     */
    ref?: React.Ref<HTMLTextAreaElement>;
};
declare const TextArea: React.ForwardRefExoticComponent<Pick<TextAreaProps, "className" | "style" | "color" | "id" | "lang" | "name" | "role" | "tabIndex" | "aria-activedescendant" | "aria-atomic" | "aria-autocomplete" | "aria-busy" | "aria-checked" | "aria-colcount" | "aria-colindex" | "aria-colspan" | "aria-controls" | "aria-current" | "aria-describedby" | "aria-details" | "aria-disabled" | "aria-dropeffect" | "aria-errormessage" | "aria-expanded" | "aria-flowto" | "aria-grabbed" | "aria-haspopup" | "aria-hidden" | "aria-invalid" | "aria-keyshortcuts" | "aria-label" | "aria-labelledby" | "aria-level" | "aria-live" | "aria-modal" | "aria-multiline" | "aria-multiselectable" | "aria-orientation" | "aria-owns" | "aria-placeholder" | "aria-posinset" | "aria-pressed" | "aria-readonly" | "aria-relevant" | "aria-required" | "aria-roledescription" | "aria-rowcount" | "aria-rowindex" | "aria-rowspan" | "aria-selected" | "aria-setsize" | "aria-sort" | "aria-valuemax" | "aria-valuemin" | "aria-valuenow" | "aria-valuetext" | "children" | "dangerouslySetInnerHTML" | "onCopy" | "onCopyCapture" | "onCut" | "onCutCapture" | "onPaste" | "onPasteCapture" | "onCompositionEnd" | "onCompositionEndCapture" | "onCompositionStart" | "onCompositionStartCapture" | "onCompositionUpdate" | "onCompositionUpdateCapture" | "onFocus" | "onFocusCapture" | "onBlur" | "onBlurCapture" | "onChange" | "onChangeCapture" | "onBeforeInput" | "onBeforeInputCapture" | "onInput" | "onInputCapture" | "onReset" | "onResetCapture" | "onSubmit" | "onSubmitCapture" | "onInvalid" | "onInvalidCapture" | "onLoad" | "onLoadCapture" | "onError" | "onErrorCapture" | "onKeyDown" | "onKeyDownCapture" | "onKeyPress" | "onKeyPressCapture" | "onKeyUp" | "onKeyUpCapture" | "onAbort" | "onAbortCapture" | "onCanPlay" | "onCanPlayCapture" | "onCanPlayThrough" | "onCanPlayThroughCapture" | "onDurationChange" | "onDurationChangeCapture" | "onEmptied" | "onEmptiedCapture" | "onEncrypted" | "onEncryptedCapture" | "onEnded" | "onEndedCapture" | "onLoadedData" | "onLoadedDataCapture" | "onLoadedMetadata" | "onLoadedMetadataCapture" | "onLoadStart" | "onLoadStartCapture" | "onPause" | "onPauseCapture" | "onPlay" | "onPlayCapture" | "onPlaying" | "onPlayingCapture" | "onProgress" | "onProgressCapture" | "onRateChange" | "onRateChangeCapture" | "onSeeked" | "onSeekedCapture" | "onSeeking" | "onSeekingCapture" | "onStalled" | "onStalledCapture" | "onSuspend" | "onSuspendCapture" | "onTimeUpdate" | "onTimeUpdateCapture" | "onVolumeChange" | "onVolumeChangeCapture" | "onWaiting" | "onWaitingCapture" | "onAuxClick" | "onAuxClickCapture" | "onClick" | "onClickCapture" | "onContextMenu" | "onContextMenuCapture" | "onDoubleClick" | "onDoubleClickCapture" | "onDrag" | "onDragCapture" | "onDragEnd" | "onDragEndCapture" | "onDragEnter" | "onDragEnterCapture" | "onDragExit" | "onDragExitCapture" | "onDragLeave" | "onDragLeaveCapture" | "onDragOver" | "onDragOverCapture" | "onDragStart" | "onDragStartCapture" | "onDrop" | "onDropCapture" | "onMouseDown" | "onMouseDownCapture" | "onMouseEnter" | "onMouseLeave" | "onMouseMove" | "onMouseMoveCapture" | "onMouseOut" | "onMouseOutCapture" | "onMouseOver" | "onMouseOverCapture" | "onMouseUp" | "onMouseUpCapture" | "onSelect" | "onSelectCapture" | "onTouchCancel" | "onTouchCancelCapture" | "onTouchEnd" | "onTouchEndCapture" | "onTouchMove" | "onTouchMoveCapture" | "onTouchStart" | "onTouchStartCapture" | "onPointerDown" | "onPointerDownCapture" | "onPointerMove" | "onPointerMoveCapture" | "onPointerUp" | "onPointerUpCapture" | "onPointerCancel" | "onPointerCancelCapture" | "onPointerEnter" | "onPointerEnterCapture" | "onPointerLeave" | "onPointerLeaveCapture" | "onPointerOver" | "onPointerOverCapture" | "onPointerOut" | "onPointerOutCapture" | "onGotPointerCapture" | "onGotPointerCaptureCapture" | "onLostPointerCapture" | "onLostPointerCaptureCapture" | "onScroll" | "onScrollCapture" | "onWheel" | "onWheelCapture" | "onAnimationStart" | "onAnimationStartCapture" | "onAnimationEnd" | "onAnimationEndCapture" | "onAnimationIteration" | "onAnimationIterationCapture" | "onTransitionEnd" | "onTransitionEndCapture" | "form" | "label" | "slot" | "title" | "dir" | "property" | "value" | "key" | "autoFocus" | "disabled" | "defaultChecked" | "defaultValue" | "suppressContentEditableWarning" | "suppressHydrationWarning" | "accessKey" | "contentEditable" | "contextMenu" | "draggable" | "hidden" | "placeholder" | "spellCheck" | "translate" | "radioGroup" | "about" | "datatype" | "inlist" | "prefix" | "resource" | "typeof" | "vocab" | "autoCapitalize" | "autoCorrect" | "autoSave" | "itemProp" | "itemScope" | "itemType" | "itemID" | "itemRef" | "results" | "security" | "unselectable" | "inputMode" | "is" | "autoComplete" | "cols" | "maxLength" | "minLength" | "readOnly" | "required" | "rows" | "wrap" | "errorText" | "labelText" | "tooltipLabel" | "invalid" | "tooltipButtonLabel" | "tooltipText" | "hideLabel" | "dirName" | "helperText" | "successText"> & React.RefAttributes<HTMLTextAreaElement>>;
type TextInputProps = React.ComponentPropsWithoutRef<"input"> & {
    /**
     * Additional class names to apply to the text input
     */
    className?: string;
    /**
     * The default input element value. Use when the component is not controlled
     */
    defaultValue?: string;
    /**
     * If `true`, the input will be disabled
     */
    disabled?: boolean;
    /**
     * The error text content that will be shown below the input
     */
    errorText?: string;
    /**
     * The helper text content that will be shown below the input
     */
    helperText?: string;
    /**
     * Hides the label above the input
     */
    hideLabel?: boolean;
    /**
     * The id of the input element
     */
    id: string;
    /**
     * If `true`, the input will be displayed in an invalid state.
     */
    invalid?: boolean;
    /**
     * The label for the input
     */
    label?: string | React.ReactNode;
    /**
     * **[DEPRECATED]** This prop will be removed in a future version. Use the `label` prop instead
     */
    labelText?: string;
    /**
     * Callback fired when the state is changed
     */
    onChange?: React.ChangeEventHandler<HTMLInputElement>;
    /**
     * Short hint displayed in the input before the user enters a value
     */
    placeholder?: string;
    /**
     * If `true`, prevents the user from changing the value of the field (not from interacting with the field)
     */
    readOnly?: boolean;
    /**
     * If `true`, the label is displayed as required and the `input` element will be required
     */
    required?: boolean;
    /**
     * Override or extend the styles applied to the component
     */
    style?: React.CSSProperties;
    /**
     * The success text content that will be shown below the input
     */
    successText?: string;
    /**
     * Aria-label text for the tooltip
     */
    tooltipLabel?: string;
    /**
     * Aria-label text for the tooltip trigger button
     */
    tooltipButtonLabel?: string;
    /**
     * The text content of the tooltip
     */
    tooltipText?: string;
    /**
     * Type of the input element
     */
    type?: string;
    /**
     * The value of the input element, required for a controlled component
     */
    value?: string;
    /**
     * The `ref` is forwarded to the native input element.
     */
    ref?: React.Ref<HTMLInputElement>;
};
declare const TextInput: React.ForwardRefExoticComponent<Pick<TextInputProps, "size" | "className" | "style" | "color" | "height" | "id" | "lang" | "max" | "min" | "name" | "type" | "width" | "role" | "tabIndex" | "crossOrigin" | "aria-activedescendant" | "aria-atomic" | "aria-autocomplete" | "aria-busy" | "aria-checked" | "aria-colcount" | "aria-colindex" | "aria-colspan" | "aria-controls" | "aria-current" | "aria-describedby" | "aria-details" | "aria-disabled" | "aria-dropeffect" | "aria-errormessage" | "aria-expanded" | "aria-flowto" | "aria-grabbed" | "aria-haspopup" | "aria-hidden" | "aria-invalid" | "aria-keyshortcuts" | "aria-label" | "aria-labelledby" | "aria-level" | "aria-live" | "aria-modal" | "aria-multiline" | "aria-multiselectable" | "aria-orientation" | "aria-owns" | "aria-placeholder" | "aria-posinset" | "aria-pressed" | "aria-readonly" | "aria-relevant" | "aria-required" | "aria-roledescription" | "aria-rowcount" | "aria-rowindex" | "aria-rowspan" | "aria-selected" | "aria-setsize" | "aria-sort" | "aria-valuemax" | "aria-valuemin" | "aria-valuenow" | "aria-valuetext" | "children" | "dangerouslySetInnerHTML" | "onCopy" | "onCopyCapture" | "onCut" | "onCutCapture" | "onPaste" | "onPasteCapture" | "onCompositionEnd" | "onCompositionEndCapture" | "onCompositionStart" | "onCompositionStartCapture" | "onCompositionUpdate" | "onCompositionUpdateCapture" | "onFocus" | "onFocusCapture" | "onBlur" | "onBlurCapture" | "onChange" | "onChangeCapture" | "onBeforeInput" | "onBeforeInputCapture" | "onInput" | "onInputCapture" | "onReset" | "onResetCapture" | "onSubmit" | "onSubmitCapture" | "onInvalid" | "onInvalidCapture" | "onLoad" | "onLoadCapture" | "onError" | "onErrorCapture" | "onKeyDown" | "onKeyDownCapture" | "onKeyPress" | "onKeyPressCapture" | "onKeyUp" | "onKeyUpCapture" | "onAbort" | "onAbortCapture" | "onCanPlay" | "onCanPlayCapture" | "onCanPlayThrough" | "onCanPlayThroughCapture" | "onDurationChange" | "onDurationChangeCapture" | "onEmptied" | "onEmptiedCapture" | "onEncrypted" | "onEncryptedCapture" | "onEnded" | "onEndedCapture" | "onLoadedData" | "onLoadedDataCapture" | "onLoadedMetadata" | "onLoadedMetadataCapture" | "onLoadStart" | "onLoadStartCapture" | "onPause" | "onPauseCapture" | "onPlay" | "onPlayCapture" | "onPlaying" | "onPlayingCapture" | "onProgress" | "onProgressCapture" | "onRateChange" | "onRateChangeCapture" | "onSeeked" | "onSeekedCapture" | "onSeeking" | "onSeekingCapture" | "onStalled" | "onStalledCapture" | "onSuspend" | "onSuspendCapture" | "onTimeUpdate" | "onTimeUpdateCapture" | "onVolumeChange" | "onVolumeChangeCapture" | "onWaiting" | "onWaitingCapture" | "onAuxClick" | "onAuxClickCapture" | "onClick" | "onClickCapture" | "onContextMenu" | "onContextMenuCapture" | "onDoubleClick" | "onDoubleClickCapture" | "onDrag" | "onDragCapture" | "onDragEnd" | "onDragEndCapture" | "onDragEnter" | "onDragEnterCapture" | "onDragExit" | "onDragExitCapture" | "onDragLeave" | "onDragLeaveCapture" | "onDragOver" | "onDragOverCapture" | "onDragStart" | "onDragStartCapture" | "onDrop" | "onDropCapture" | "onMouseDown" | "onMouseDownCapture" | "onMouseEnter" | "onMouseLeave" | "onMouseMove" | "onMouseMoveCapture" | "onMouseOut" | "onMouseOutCapture" | "onMouseOver" | "onMouseOverCapture" | "onMouseUp" | "onMouseUpCapture" | "onSelect" | "onSelectCapture" | "onTouchCancel" | "onTouchCancelCapture" | "onTouchEnd" | "onTouchEndCapture" | "onTouchMove" | "onTouchMoveCapture" | "onTouchStart" | "onTouchStartCapture" | "onPointerDown" | "onPointerDownCapture" | "onPointerMove" | "onPointerMoveCapture" | "onPointerUp" | "onPointerUpCapture" | "onPointerCancel" | "onPointerCancelCapture" | "onPointerEnter" | "onPointerEnterCapture" | "onPointerLeave" | "onPointerLeaveCapture" | "onPointerOver" | "onPointerOverCapture" | "onPointerOut" | "onPointerOutCapture" | "onGotPointerCapture" | "onGotPointerCaptureCapture" | "onLostPointerCapture" | "onLostPointerCaptureCapture" | "onScroll" | "onScrollCapture" | "onWheel" | "onWheelCapture" | "onAnimationStart" | "onAnimationStartCapture" | "onAnimationEnd" | "onAnimationEndCapture" | "onAnimationIteration" | "onAnimationIterationCapture" | "onTransitionEnd" | "onTransitionEndCapture" | "form" | "label" | "slot" | "title" | "pattern" | "dir" | "property" | "value" | "key" | "autoFocus" | "disabled" | "formAction" | "formEncType" | "formMethod" | "formNoValidate" | "formTarget" | "defaultChecked" | "defaultValue" | "suppressContentEditableWarning" | "suppressHydrationWarning" | "accessKey" | "contentEditable" | "contextMenu" | "draggable" | "hidden" | "placeholder" | "spellCheck" | "translate" | "radioGroup" | "about" | "datatype" | "inlist" | "prefix" | "resource" | "typeof" | "vocab" | "autoCapitalize" | "autoCorrect" | "autoSave" | "itemProp" | "itemScope" | "itemType" | "itemID" | "itemRef" | "results" | "security" | "unselectable" | "inputMode" | "is" | "list" | "step" | "accept" | "alt" | "autoComplete" | "capture" | "checked" | "maxLength" | "minLength" | "multiple" | "readOnly" | "required" | "src" | "errorText" | "labelText" | "tooltipLabel" | "invalid" | "tooltipButtonLabel" | "tooltipText" | "hideLabel" | "helperText" | "successText"> & React.RefAttributes<HTMLInputElement>>;
type TooltipProps = React.PropsWithChildren<{
    /**
     * The placement of the tooltip.
     */
    placement?: Placement;
    /**
     * Use the small tooltip variant.
     */
    small?: boolean;
    /**
     * Aria-label text for the tooltip trigger button.
     */
    buttonLabel?: string;
    /**
     * Aria-label text for the tooltip.
     */
    tooltipLabel?: string;
    /**
     * Additional wrapper class names.
     */
    className?: string;
    /**
     * Additional button class names.
     */
    buttonClassName?: string;
    /**
     * Additional tooltip class names.
     */
    tooltipClassName?: string;
}>;
declare const Tooltip: ({ children, placement, small, buttonLabel, tooltipLabel, className, buttonClassName, tooltipClassName }: TooltipProps) => JSX.Element;
export { IconProps, IconDiscord, IconFacebook, IconGoogle, IconInstagram, IconLinkedin, IconRss, IconSnapchat, IconTiktok, IconTwitch, IconTwitter, IconVimeo, IconYle, IconYoutube, IconAlertCircle, IconAngleRight, IconAngleLeft, IconAngleDown, IconAngleUp, IconArrowDown, IconArrowLeft, IconArrowRedo, IconArrowUndo, IconArrowRight, IconArrowUp, IconBellCrossed, IconCalendarClock, IconCalendarPlus, IconCalendarCross, IconBell, IconCalendar, IconCamera, IconCheck, IconClockCross, IconClockPlus, IconClock, IconCogwheel, IconCrossCircle, IconCross, IconDisplay, IconDownloadCloud, IconDownload, IconEnvelope, IconEye, IconFaceNeutral, IconEyeCrossed, IconError, IconFaceSad, IconGlobe, IconFaceSmile, IconGroup, IconHeartFill, IconHomeSmoke, IconHeart, IconInfoCircle, IconHome, IconLinkExternal, IconLink, IconLocate, IconLock, IconLocation, IconLockOpen, IconMap, IconMenuDots, IconMenuHamburger, IconMicrophone, IconMicrophoneCrossed, IconMinusCircle, IconMinus, IconPaperclip, IconMobile, IconPenLine, IconPen, IconPersonFemale, IconPersonMale, IconPersonWheelchair, IconPhone, IconPlusCircle, IconPhoto, IconPhotoPlus, IconPlus, IconQuestionCircle, IconShare, IconSearch, IconSignin, IconSignout, IconSpeechbubbleText, IconSpeechbubble, IconStarFill, IconStar, IconTicket, IconTrash, IconUploadCloud, IconUpload, IconUser, IconVideocameraCrossed, IconVideocamera, IconVolumeHigh, IconVolumeMinus, IconVolumeLow, IconVolumeMute, IconWifiCrossed, IconVolumePlus, IconWifi, IconZoomIn, IconZoomOut, IconZoomText, IconAlertCircleFill, IconCake, IconCalendarRecurring, IconCheckCircleFill, IconCheckCircle, IconCrossCircleFill, IconDrag, IconErrorFill, IconInfoCircleFill, IconGlyphEuro, IconLayers, IconGlyphAt, IconPlaybackFastforward, IconMinusCircleFill, IconPlaybackPause, IconPlaybackPlay, IconPlaybackNext, IconPlaybackPrevious, IconPlaybackRecord, IconPlaybackRewind, IconPlaybackStop, IconPlusCircleFill, IconPodcast, IconPrinter, IconQuestionCircleFill, IconRefresh, IconSortAscending, IconSortAlphabeticalAscending, IconSliders, IconSortDescending, IconSortAlphabeticalDescending, IconSort, AccordionCustomTheme, CommonAccordionProps, CardAccordionProps, AccordionProps, Accordion, AccordionConfig, AccordionButtonProps, AccordionContentProps, AccordionState, useAccordion, ButtonSize, ButtonTheme, ButtonVariant, CommonButtonProps, SupplementaryButtonProps, ButtonProps, Button, CardCustomTheme, CardProps, Card, CheckboxProps, Checkbox, ColumnsProps, Columns, ContainerProps, Container, DropdownProps, Dropdown, SelectCustomTheme, CommonSelectProps, SingleSelectProps, MultiSelectProps, SelectProps, onMultiSelectStateChange, multiSelectReducer, Select, ComboboxProps, Combobox, ErrorSummarySize, ErrorSummaryProps, ErrorSummary, FooterProps, Footer, FooterReducerState, FooterReducerAction, FooterNavigationVariant, FooterTheme, FooterCustomTheme, ImageWithCardAlignment, ImageWithCardLayout, ImageWithCardColor, ImageWithCardProps, ImageWithCard, KorosType, KorosProps, Koros, LoadingSpinnerCustomTheme, LoadingSpinnerProps, LoadingSpinner, LogoLanguage, LogoSize, LogoProps, Logo, NavigationProps, Navigation, NotificationType, NotificationSizeInline, NotificationSizeToast, NotificationPosition, NotificationProps, Notification, RadioButtonProps, RadioButton, SearchInputProps, SearchInput, SectionColor, SectionProps, Section, Direction, SelectionGroupProps, SelectionGroup, StatusLabelType, StatusLabelProps, StatusLabel, TagCustomTheme, TagProps, Tag, TextAreaProps, TextArea, TextInputProps, TextInput, Tooltip };
